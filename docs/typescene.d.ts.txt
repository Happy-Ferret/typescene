declare module "@typescene/async/Async/Defer" {
/** Execute given function only when idle, with given arguments (array or `arguments` object) if any */
export function defer(f: (...args: any[]) => void, args?: any[] | IArguments): void;
/** Run a batch of deferred functions; returns true if there are still more deferred functions in the queue (or false to stop infinite recursion if already running) */
export function yieldAll(): boolean;

}

declare module "@typescene/async/Async" {
export * from "@typescene/async/Async/Defer";
export * from "@typescene/async/Async/Signal";
export * from "@typescene/async/Async/Promise";
export * from "@typescene/async/Async/Observable";
export * from "@typescene/async/Async/ObservableArray";
export * from "@typescene/async/Async/ObservableObject";
export * from "@typescene/async/Async/Inject";

}

declare module "@typescene/async/Async/Inject" {
/** _Property decorator_, makes a property observable on every instance, with a read-only value shared across all instances taken from an (earlier OR later) call to `inject`, *until* the property is directly assigned to [requires ES5+ target] [decorator] */
export function injectable(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** Set given injectable observable properties (decorated with `injectable`) on *all* instances of given class and derived classes to the given values, except for instances where the property has been overwritten directly; may be called multiple times even with the same properties to redefine their injected value; returns an object that contains the previous injected values (for e.g. overriding an injected function that calls into the previously injected function; when injecting into a derived class, these properties use accessors to return latest overridden injected values on base class(es) dynamically) */
export function inject<SpecT extends {
    [name: string]: any;
}>(targetClass: Function, spec: SpecT): SpecT;

}

declare module "@typescene/async/Async/Observable" {
import { Promise } from "@typescene/async/Async/Promise";
import { Signal } from "@typescene/async/Async/Signal";
import { ObservableObject } from "@typescene/async/Async/ObservableObject";
import { ObservableArray } from "@typescene/async/Async/ObservableArray";
/** Represents an observable value (with the value itself in `.value`) */
export class ObservableValue<T> {
    /** Returns true if currently running in a subscribed-to observable context (i.e. evaluating an observable value, recording dependencies on other observable values being accessed from this context) */
    static isObserving(): boolean;
    /** Encapsulate given value as an ObservableValue */
    static fromValue<T>(value: T): ObservableValue<T>;
    /** Encapsulate given promised value as an ObservableValue; the observed value will start out as `undefined` but then changes to the `Promise` result when resolved; or if promise was rejected, hangs on to the error and throws it when retrieving the observable value */
    static fromPromise<T>(valuePromise: PromiseLike<T>): ObservableValue<T>;
    /** Connect to given `Signal`, and create a read-only observable value that always contains the last emitted signal value (initially undefined; the value is only set after the next time the signal is emitted) */
    static fromSignal<T>(signal: Signal.Emittable<T, typeof Signal>): ObservableValue<T>;
    /** Create a new (single) observed value using optional getter and setter functions; note that getters *should* be pure functions without side effects, creating or setting other observables from the getter will result in an error; getter is not called immediately but only when being subscribed to or when obtaining the value itself (from `.value`) */
    constructor(getter?: () => T, setter?: (value: T) => void);
    /** Set a getter function for the observable value, which should return a current value, or another ObservableValue instance, or set `.value` directly; note that getters *should* be pure functions without side effects, creating or setting other observables from the getter will result in an error; the getter is only invoked (asynchronously) if a value had been set previously and needs to be updated; reading `.value` from the getter results in the value previously set, no recursion occurs; returns this */
    getter(f: () => T): this;
    /** Set a setter function for the observable value; setting `.value` directly from the setter results in changing the underlying observable value (which can also be read by the getter, or the setter itself), no recursion occurs; returns this */
    setter(f: (value: T) => void): this;
    /** Observable value, (re-) evaluated only if necessary; when set to an `ObservableValue` instance, this property returns that instance's value, until this property is set to another value (except if the `ObservableValue` has a setter, which is called first); plain Array values are turned into `ObservableArray` instances, and plain Object instances into `ObservableObject` instances --- unless `.shallow` is set to true */
    value: T | undefined;
    /** Returns .value (observable if used within an observable getter) */
    valueOf(): T | undefined;
    /** Returns .value as a string (observable if used within an observable getter) */
    toString(): string;
    /** Returns last value set, does not re-evaluate and/or add dependency */
    getLastValue(): T | undefined;
    /** Transform this observable value using given function, into a new ObservableValue instance; note that the transformation function is not necessarily invoked after each value change, if the new observable is not subscribed to and/or multiple changes occur (asynchronously) before the transformation is evaluated; observables used by the given function itself are not automatically subscribed to (wrap given function in observe(...) to observe dependencies as well) */
    map<U>(callback: (value: T) => U): ObservableValue<U>;
    /** Start listening for changes to this observable value and all of its dependencies asynchronously; returns this */
    subscribe(): this;
    /** Start listening for changes to this observable value and all of its dependencies asynchronously, and schedule given function for every new value (including the current value, or undefined if none has been set); returns this */
    subscribe(callback: (value: T) => any): this;
    /** Start listening for changes to this observable value and all of its dependencies asynchronously, and return a promise for the next (different) value of the observable; does _not_ force evaluation of the current value (i.e. getters are not called); stops subscribing immediately after the promise is resolved */
    next(): Promise<T>;
    /** True if this observable value is currently subscribed to, either directly or from dependent observables */
    readonly subscribed: boolean;
    /** True if this observable value is writable (not only a getter defined) */
    readonly writable: boolean;
    /** Set to true to stop this observablue value instance from converting arrays and objects to observables, and reading values from observable value instances */
    shallow?: boolean;
    /** Clear value and remove getter/setter functions, unsubscribe from dependencies */
    clear(): void;
    /** Manually invoke the getter function synchronously, if any; can be used only if not currently evaluating another observable value (otherwise, wrap in a call to `unobserved`); calling this method is normally not necessary, and should only be used if external factors outside of observables change in such a way that the result of the getter function changes; if so, then subsequent retrieval of `.value` results in the new value, and dependent observable values are scheduled to update automatically (asynchronously) */
    update(): void;
}
/** Create a (single) observable that holds the return value of the given function, re-evaluated (when subscribed to) whenever one of the observable values used in the getter function change, *or* (also when not subscribed to) when `ObservableValue#value` is read after one of the observables used in the getter function (may have) changed its value; note that getters *should* be pure functions without side effects, creating or setting other observables from the getter will result in an error */
export function observe<T>(f: () => T): ObservableValue<T>;
/** Encapsulate given promise as an observable value that is set when the promise resolves; if the promise is already resolved, the observable value is set to the promise's value immediately; if or when the promise is rejected, the error is stored and will be thrown when trying to obtain the observable value */
export function observe<T>(promise: PromiseLike<T>): ObservableValue<T>;
/** Returns a new ObservableArray with elements copied from given array; (same as `ObservableArray.fromArray`; does not observe values of a given `ObservableArray`, see `observeArray` instead) */
export function observe<T>(obj: Array<T>): ObservableArray<T>;
/** Returns a new ObservableObject with properties copied from given object; (same as new ObservableObject(...) but with a strongly typed return value) */
export function observe<T extends {}>(obj: T): T & ObservableObject;
/** Invoke given function without recording dependencies on currently evaluating observable values; passes on the `this` value given to this function, returns the function's return value */
export function unobserved<T>(f: ((...args: any[]) => T), ...args: any[]): T;

}

declare module "@typescene/async/Async/ObservableArray" {
import { ObservableValue } from "@typescene/async/Async/Observable";
/** Encapsulates `Array` with observable properties; the result works exactly like a regular array, but setting elements outside the bounds of the array (>= length) does NOT work: length must be set first */
export class ObservableArray<T> {
    /** Create an `ObservableArray` out of a regular Array */
    static fromArray<T>(array: Array<T>): ObservableArray<T>;
    /** Create an `ObservableArray` that takes array elements from the array in given `ObservableValue`, or the value itself as a single element if it is not an array, or an empty array if the value is null or undefined; changes in array elements and/or observable value are reflected asynchronously */
    static fromObservableValue<T>(observableValue: ObservableValue<T[] | T | undefined>): ObservableArray<T>;
    /** Create a new empty `ObservableArray` instance */
    constructor();
    /** Create a read-only `ObservableArray` with each value of the original array mapped to the result of the given getter function; observable values used in the map function are not observed (like `ObservableValue#map`); the getter is called for combinations of value and index (i.e. deleting a value in the middle of the source array will trigger changes for all elements after it; if the index is not important then use `.mapAsyncValues` instead); the resulting array length changes along with the original array length */
    mapAsync<U>(callback: (value: T, index: number, array: T[]) => (ObservableValue<U> | U), thisArg?: any): ObservableArray<U>;
    /** Create a read-only ObservableArray with each value of the original array mapped to the result of the given function; observable values used in the map function are not observed (like ObservableValue map method); the resulting array length changes along with the original array length; this method is slightly more expensive than mapAsync for larger arrays, especially in non-ES6 environments, but is overall more efficient because it avoids unnecessary callbacks when subscribed to */
    mapAsyncValues<U>(callbackfn: (value: T) => (ObservableValue<U> | U)): ObservableArray<U>;
    /** Create a read-only observable array that contains all values from the original array and all nested (observable) arrays, optionally removing gaps (i.e. undefined or null elements); the resulting array and its length _always_ change asynchronously with the contents of the original array, even if not subscribed to a value or the length property */
    flattenAsync(removeGaps?: boolean): ObservableArray<T>;
    /** Represent observable arrays as regular JSON arrays */
    toJSON(): T[];
}
/** Type definition to declare Array methods mixin */
export interface ObservableArray<T> extends Array<T> {
}
/** Returns an ObservableArray instance based on the result of given function: if the returned value is an array, then all elements are copied to the result; if the returned value is an observable array, all elements are proxied; if the returned value is not an array, the result contains this value as a single element; if the returned value is null or undefined, the result will be an empty array; changes in values/elements are reflected asynchronously */
export function observeArray<T>(f: () => (T[] | T | undefined)): ObservableArray<T>;

}

declare module "@typescene/async/Async/ObservableObject" {
import { Signal } from "@typescene/async/Async/Signal";
import { ObservableValue } from "@typescene/async/Async/Observable";
/** Represents an object with (some) observable members; may be extended into a derived class, or use `makeObjectObservable` function to mix into any object [requires ES5+ target] */
export class ObservableObject {
    /** Create an object with (some) observable members */
    constructor();
    /** Returns true if property with given name is observable */
    hasObservableProperty(name: string | number): boolean;
    /** Signal that is emitted when any property changes (but does not subscribe to any properties, i.e. only changes to properties already subscribed to, and properties with plain values [not getters] will trigger this signal) */
    PropertyChange: Signal.Emittable<string, typeof ObservableObject.PropertyChangeSignal>;
}
export namespace ObservableObject {
    /** Base class for signals that are emitted when any observed property is modified on an ObservableObject instance, with the name of the property as a parameter */
    class PropertyChangeSignal extends Signal<string> {
        /** The ObservableObject instance that this signal is used on */
        static target: ObservableObject;
    }
}
/** Returns a new `ObservableObject` with properties copied from given object; `ObservableValue` instances are referenced directly (including getter and setter), Array properties are turned into `ObservableArray` instances, and plain Object instances into `ObservableObject` instances; also seals the new instance if the object parameter was sealed, and freezes it if the object parameter was frozen*/
export function makeObjectObservable<T extends {}>(obj: T): T & ObservableObject;
/** Make the property with given name observable; use given observable value instance, if any, otherwise use a new observable value instance that holds the current property value and/or uses the current property getter and setter [requires ES5+ target] */
export function makePropertyObservable(obj: {}, member: string | number, instance?: ObservableValue<any>): void;
/** Delete the property with given name and clear its observable value */
export function deleteObservableProperty(obj: {}, member: string | number): void;
/** Returns true if property with given name is defined and is observable */
export function isObservableProperty(obj: {}, member: string | number): boolean;
/** _Method/accessor decorator_, wraps a method or getter (but not setter) in an `unobserved` call, so that any observable values read by this method (or functions invoked synchronously from within this method) are not marked as dependencies of any currently evaluating observable values [requires ES5+ target] [decorator] */
export function unobservable(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** _Read-only-accessor decorator_, wraps a getter (without setter) in an `unobserved` call, so that any observable values read by the accessor (or functions invoked synchronously from within the accessor) are not marked as dependencies of any currently evaluating observable values; defines a read-only property using the result of the accessor call, after the first time it was invoked for each instance [requires ES5+ target] [decorator] */
export function unobservable_memoize_get(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** _Property/accessor decorator_, makes a property observable on every instance [requires ES5+ target] [decorator] */
export function observable(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** _Property/accessor decorator_, makes a property observable on every instance and converts values to strings when read (empty string for null/undefined/NaN) [requires ES5+ target] [decorator] */
export function observable_string(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** _Property/accessor decorator_, makes a property observable on every instance and converts values to numbers using Number(...) when read [requires ES5+ target] [decorator] */
export function observable_number(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** _Property/accessor decorator_, makes a property observable on every instance, as a shallow observable value (i.e. does not read values from observable values assigned to this property; and does not convert arrays to observable arrays nor objects to observable objects) [requires ES5+ target] [decorator] */
export function observable_shallow(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** _Property/accessor decorator_, makes a property observable on every instance and enforces that values are not undefined or null when read (throws TypeError) and that undefined/null values cannot be set (also throws TypeError) [requires ES5+ target] [decorator] */
export function observable_not_null(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** _Property/accessor decorator_, makes a property observable on every instance and enforces that values are not undefined or null when read (throws TypeError) and that only instances of Object can be set, which are sealed automatically [requires ES5+ target] [decorator] */
export function observable_seal(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** _Property/accessor decorator_, makes a property observable on every instance and enforces that values are not undefined or null when read (throws TypeError) and that only instances of Object can be set, which are frozen automatically [requires ES5+ target] [decorator] */
export function observable_freeze(target: Object, key: string, descriptor?: PropertyDescriptor): any;

}

declare module "@typescene/async/Async/Promise" {
/** Represents a value to be resolved at any time in the future */
export class Promise<T> implements PromiseLike<T> {
    /** Delay the execution of a callback but return a promise for its result */
    static delay<T>(f: (...args: any[]) => T, ms: number, args?: any[]): Promise<T>;
    /** Return a promise that will be resolved after a delay */
    static sleep<T>(ms: number, value?: T): Promise<T>;
    /** Defer the execution of a callback but return a promise for its result */
    static defer<T>(f: (...args: any[]) => T, args?: any[]): Promise<T>;
    /** Executes given callback, providing it with a Node.js-style (err, result) => {...} handler that immediately resolves or rejects the resulting promise when called; (use as e.g. `Promise.fn(f => fs.readFile('/etc/passwd', f)).then(...))` */
    static fn<T>(callback: (f: (err: any, result: T) => void) => void): Promise<T>;
    /** Return a resolved promise */
    static resolve<T>(value: T): Promise<T>;
    /** Return a rejected promise */
    static reject(error: Error): Promise<{}>;
    /** Return a promise that is fulfilled when all given promises are fulfilled and is immediately rejected when one of the promises is rejected */
    static all<ValueT>(promises: PromiseLike<ValueT>[]): Promise<ValueT[]>;
    /** Return a promise that is resolved or rejected exactly like the first of the given promises that is resolved or rejected */
    static race<T>(promises: PromiseLike<T>[]): Promise<T>;
    /** Create a new Promise instance by running the given callback function, which is given callbacks to resolve and/or reject the promise; the promise is also rejected if the callback function throws an exception */
    constructor(executor?: (resolve: (value: PromiseLike<T> | T) => void, reject: (error: Error) => void) => void);
    /** Run one of the callbacks as soon as the promise is fulfilled or rejected */
    then<O>(onFulfilled?: (value: T) => (PromiseLike<O> | O), onRejected?: (error: Error) => (PromiseLike<O> | O)): Promise<O>;
    /** Run one of the callbacks as soon as the promise is fulfilled or rejected */
    then<O>(onFulfilled?: (value: T) => (PromiseLike<O> | O), onRejected?: (error: Error) => void): Promise<O>;
    /** Catch rejections and return a new promise */
    catch<O>(onRejected?: (error: Error) => (PromiseLike<O> | O)): Promise<O>;
    /** Catch rejections and return a new promise */
    catch<O>(onRejected?: (error: Error) => void): Promise<O>;
}
/** Return a promise that will be resolved after a delay */
export function sleep<PromiseT>(ms: number, value?: PromiseT): Promise<PromiseT | undefined>;

}

declare module "@typescene/async/Async/Signal" {
import { Promise } from "@typescene/async/Async/Promise";
import { ObservableValue } from "@typescene/async/Async";
/** Encapsulates a handler connected to a signal */
export interface SignalConnection {
    /** Disconnect the connected handler from this signal */
    disconnect(): void;
    /** True if connection has been disconnected */
    disconnected: boolean;
}
/** Encapsulates a signal that can be used to trigger one or more handlers asynchronously; do _not_ construct `Signal` classes directly, use `defineSignal` to create derived classes which can be instantiated and emitted */
export abstract class Signal<T> {
    /** [implementation] Create a read-only observable value that contains the last emitted value (initially undefined, only contains a value after the first time this signal is emitted) */
    static observe(): ObservableValue<{}>;
    /** [implementation] Add a handler */
    static connect(callback: any, target?: {}): SignalConnection;
    /** [implementation] Add a one-time handler */
    static connectOnce(callback: any, target?: {}): void;
    /** [implementation] Remove all handlers */
    static disconnectAll(): typeof Signal;
    /** [implementation] Returns true if this signal has any handlers */
    static isConnected(): boolean;
    /** Static method that is called synchronously when a first handler is connected (and when a new handler is connected after all had been disconnected); override this in a signal base class, e.g. to add a delayed initialization method */
    protected static onHandlerConnected?: () => void;
    /** Static method that is called synchronously when no more handlers are connected; override this in a signal base class, e.g. to add a delayed deallocation method */
    protected static onHandlersDisconnected?: () => void;
    /** Create a signal with given payload data, ready to be emitted */
    constructor(data: T);
    /** Invoke all handlers and capture promises of their return values in .results (unless argument is true); works only once; returns this */
    emit(noResults?: boolean): this;
    /** Invoke given callback(s) with return values of all handlers, or any exception that occurred during execution of all handlers; returns a Promise that resolves to the return value of the callback(s) itself */
    then<O>(onFulfilled?: (results: any[]) => O, onRejected?: (error: Error) => O): Promise<O>;
    /** Catch errors that occur during execution of all handlers; returns a Promise that resolves to the return value of the callback itself */
    catch<O>(onRejected?: (error: Error) => O): Promise<O>;
    /** Array of Promises that resolve to return values of all handlers */
    readonly results: Promise<any>[];
    /** The payload data for this signal instance */
    readonly data: T;
}
export namespace Signal {
    /** Type definition for a callable (emittable) signal *class*; matches the result of `defineSignal`; the type parameters represent handler function arguments: signal payload, and emitted signal type */
    interface Emittable<T, SignalClassT extends typeof Signal> {
        /** Instantiate a signal with given value, ready to be emitted */
        new (data: T): Signal<T>;
        /** Emit a signal with given value; does not instantiate this class unless there are actually handlers connected to it */
        (data?: T): void;
        /** Add a handler to be invoked when this signal is emitted; returns an encapsulation of the connection with a disconnect method */
        connect(handler: (data: T, source: SignalClassT) => any): SignalConnection;
        /** Add a handler to be invoked when this signal is emitted: a method with given name on given target object (resolved only when needed); returns an encapsulation of the connection with a disconnect method */
        connect(method: string, target: {}): SignalConnection;
        /** Add a handler to be invoked the next time this signal is emitted */
        connectOnce(handler: (data: T, source: SignalClassT) => any): void;
        /** Add a handler to be invoked the next time this signal is emitted: a method with given name on given target object (resolved only when needed) */
        connectOnce(method: string, target: {}): void;
        /** Remove all handlers */
        disconnectAll(): this;
        /** Returns true if this signal has any handlers connected to it */
        isConnected(): boolean;
        /** Create a read-only observable value that contains the last emitted value (initially undefined, only contains a value after the first time this signal is emitted) */
        observe(): ObservableValue<T>;
    }
}
/** Create a new emittable signal class that derives directly from `Signal`, with given payload type */
export function defineSignal<T>(): Signal.Emittable<T, typeof Signal>;
/** Create a new emittable signal class that derives from given base class (which must derive from `Signal`), and copy given static properties onto the resulting class */
export function defineSignal<SignalT extends typeof Signal, T>(Base: SignalT & {
    new (...args): {
        data: T;
    };
}, properties?: {}): SignalT & Signal.Emittable<T, SignalT>;
/** Signal that is triggered with exceptions that were unhandled during async execution; a custom handler may be added here, the default handler just writes a warning message to the console; to disable this behavior for specific errors, set error.message to a blank string */
export const UnhandledException: Signal.Emittable<Error, typeof Signal>;

}

declare module "@typescene/async" {
export * from "@typescene/async/Async";
import * as Async from "@typescene/async/Async";
export default Async;

}

declare module "@typescene/ui" {
export * from "@typescene/ui/UI";
import * as UI from "@typescene/ui/UI";
export default UI;

}

declare module "@typescene/ui/UI/Animation" {
import { Component } from "@typescene/ui/UI";
/** Represents a UI component animation */
export abstract class Animation {
    static enableAll(): void;
    static disableAll(): void;
    static readonly isEnabled: boolean;
    constructor(name: string);
    /** Unique ID (includes name and a unique number, generated by constructor) */
    readonly id: string;
    /** Name of the animation (not necessarily unique) */
    readonly name: string;
    /** Total duration in milliseconds of (the looping segment of) this animation, set by implementation */
    duration: number;
    /** Play the animation on given component */
    abstract play(component: Component): Animation.AnimationControl<Animation>;
    /** Play the animation once for the entire duration, and then stop it */
    playOnce(component: Component): Animation.AnimationControl<Animation>;
}
export namespace Animation {
    /** Represents the public interface for a playing animation */
    interface AnimationControl<AnimationT extends Animation> {
        /** Reference to the animation itself */
        animation: AnimationT;
        /** Stop playing the animation, clear its artifacts */
        stop(): void;
        /** Promise that resolves to the animation control itself, after the animation is over (duration has passed) */
        done: PromiseLike<AnimationControl<AnimationT>>;
    }
}

}

declare module "@typescene/ui/UI/Binding" {
import * as Async from "@typescene/async";
import { Component } from "@typescene/ui/UI";
/** Represents a property binding, used with component factories to proxy values taken from the base component instance onto properties of its sub components */
export class Binding<ResultT> {
    /** Create a new binding based on the given property name/path (referring to the base component, on which .with or .initializeWith was called; resulting values can also be instances of ObservableValue or Promise), and optionally a transformation function, invoked each time the observed value changes (outside of any observable context, like `map` on `ObservableValue`, i.e. no further dependencies are recorded); if no path is specified, the name of the initializer property that contains this binding is used, if any */
    constructor(sourcePath?: string, getTransform?: (value: any, baseComponent: Component) => (ResultT | Async.ObservableValue<ResultT> | PromiseLike<ResultT>));
    /** Make an ObservableValue that is bound to the value on given component (used by factory initializer to apply binding) */
    observeOn(component: Component, name?: string): Async.ObservableValue<ResultT>;
}
/** Represents a two-way binding (`Binding` that also includes a setter on the proxy property) */
export class TwoWayBinding<ResultT> extends Binding<ResultT> {
    /** Create a new two-way binding based on the given property name/path (see `new Binding`), and optionally a transformation function, invoked each time a new value is being set (outside of any observable context); if no path is specified, the name of the initializer property that contains this binding is used, if any */
    constructor(sourcePath?: string, getTransform?: (value: any, baseComponent: Component) => (ResultT | Async.ObservableValue<ResultT> | PromiseLike<ResultT>), setTransform?: (value: any, baseComponent: Component) => any);
    /** Make an ObservableValue that is bound to the value on given component (used by factory initializer to apply binding) */
    observeOn(component: Component, name?: string): Async.ObservableValue<ResultT>;
}
/** Represents an array property binding, used with component factories to proxy arrays taken from the base component instance onto array properties of its sub components */
export class ArrayBinding<ItemT> extends Binding<ItemT[]> {
    /** Create a new binding based on the given property name/path, getter transformation function (see `Binding` constructor), and array element transformation function, to be passed to `mapAsync` or `mapAsyncValues` (if `uniqueValues` argument is true) */
    constructor(sourcePath?: string, getTransform?: (array: any, baseComponent: Component) => any, itemTransform?: (value: any, baseComponent: Component) => ItemT, uniqueValues?: boolean);
    /** Create a new binding based on the given property name/path, getter transformation function (see `Binding` constructor), and array element transformation function, to be passed to `mapAsync` or `mapAsyncValues` (if `uniqueValues` argument is true); if `flatten` argument is true, the element transformation function may return an array of results as well, to be flattened into the final result (with undefined/null values removed) */
    constructor(sourcePath?: string, getTransform?: (array: any, baseComponent: Component) => any, itemTransform?: (value: any, baseComponent: Component) => (ItemT | ItemT[]), uniqueValues?: boolean, flatten?: boolean);
    /** Make an ObservableValue that is bound to the value on given component (used by factory initializer to apply binding); wraps an observable array in an observable value; for better performance, use `.observeArrayOn(...)` directly (used by component factory initializer) */
    observeOn(component: Component, name?: string): Async.ObservableValue<ItemT[]>;
    /** Make an ObservableArray that is bound to the value on given component (used by factory initializer to apply binding) */
    observeArrayOn(component: Component, name?: string): Async.ObservableArray<ItemT>;
}
/** Create a new `Binding` for a property on the base component with the same name as the component initializer property
 * @see bind2
 */
export function bind(): Binding<any>;
/** Create a new `Binding` for given property name/path on the base component; for use in a component initializer */
export function bind(sourcePath: string): Binding<any>;
/** Create a new `Binding` for given property name/path on the base component, and transformation function; for use in a component initializer */
export function bind<T>(sourcePath: string, getTransform: (value: any) => T): Binding<T>;
/** Create a new `TwoWayBinding` for a property on the base component with the same name as the component initializer property */
export function bind2(): TwoWayBinding<any>;
/** Create a new `TwoWayBinding` for given property name/path on the base component; for use in a component initializer */
export function bind2(sourcePath: string): TwoWayBinding<any>;
/** Create a new `TwoWayBinding` for given property name/path on the base component, and transformation function(s); for use in a component initializer */
export function bind2<T>(sourcePath: string, getTransform: (value: any) => T, setTransform?: (value: any) => any): Binding<T>;
/** Create a new `ArrayBinding` for given property name/path on the base component, which should contain an array; the binding resolves to an observable array of instances of given `Component` class (with a constructor that takes one or two arguments: the original array element value, and optionally the base component reference); for use in a component initializer; uses `mapAsync` on the observable array by default: deleting a value in the middle of the array will trigger reinstantiation of all components after it; to use `mapAsyncValues` for better results with arrays of objects, set the `uniqueValues` argument to true; to create components asynchronously in batches, set the `batchSize` argument to a number */
export function bindComponents<ComponentT extends Component>(sourcePath: string, componentClass: {
    new (value: any, baseComponent: Component): ComponentT;
}, uniqueValues?: boolean, batchSize?: number): ArrayBinding<Component>;

}

declare module "@typescene/ui/UI/Components/Blocks/Block" {
import { Component } from "@typescene/ui/UI/Components/Component";
import { Page } from "@typescene/ui/UI/Page";
/** Block base class: full-width block component */
export class Block extends Component {
    /** Create a new empty block component */
    constructor();
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Block.Initializer) => this;
    /** Overlay position (observed); set to one of the `OverlayPosition` enum's values to take this block out of the top-down component flow, and position it relative to its _parent_ container (or to the screen, if displayed directly); note that this block will still move up/down along with the content of the parent container if its `scrollable` property is true */
    overlayPosition?: Block.OverlayPosition;
    /** Object with options to be used when displaying this block as a page component, initially undefined (observed) */
    displayOptions?: Page.DisplayOptions;
}
export namespace Block {
    /** Initializer for .with({...}) */
    interface Initializer extends Component.Initializer {
        /** Property initializer: overlay positioning option (to display block as an overlay within its parent container) */
        overlayPosition?: OverlayPosition;
        /** Property initializer: display options (for use when displayed directly on the page) */
        displayOptions?: Page.DisplayOptions;
    }
    /** Overlay positioning options */
    enum OverlayPosition {
        /** Top (full width) */
        Top = 0,
        /** Top left corner */
        TopLeft = 1,
        /** Top right corner */
        TopRight = 2,
        /** Bottom (full width) */
        Bottom = 3,
        /** Bottom left corner */
        BottomLeft = 4,
        /** Bottom right corner */
        BottomRight = 5,
    }
}

}

declare module "@typescene/ui/UI/Components/Blocks/Card" {
import { Block } from "@typescene/ui/UI/Components";
import { Component } from "@typescene/ui/UI/Components/Component";
import { ComponentFactory } from "@typescene/ui/UI/Components/ComponentFactory";
/** Represents a card block containing a header, content, and a footer */
export class Card extends Block {
    /** Create a card block with given content, if any */
    constructor(content?: Block[]);
    /** Initialize a card block factory with given content */
    static withContent<T extends Card>(this: {
        new (): T;
        with: typeof Card.with;
    }, content: ComponentFactory.SpecList2): ComponentFactory<T>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Card.Initializer) => this;
    /** Block to be displayed as a header, may be undefined (observed) */
    header?: Block;
    /** Block to be displayed as a footer, may be undefined (observed) */
    footer?: Block;
    /** Array of main content blocks, stacked top to bottom (observed) */
    content: Array<Block | undefined>;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
export namespace Card {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Block.Initializer {
        /** Property initializer: content blocks */
        content?: ComponentFactory.SpecList2;
        /** Property initializer: header block */
        header?: ComponentFactory.SpecEltOrList;
        /** Property initializer: footer block */
        footer?: ComponentFactory.SpecEltOrList;
    }
}

}

declare module "@typescene/ui/UI/Components/Blocks/ContainerBlock" {
import { Container } from "@typescene/ui/UI/Components";
import { Component } from "@typescene/ui/UI/Components/Component";
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { Block } from "@typescene/ui/UI/Components/Blocks/Block";
/** Represents a block with an embedded sub container within its margins/padding */
export class ContainerBlock<ContainerT extends Container> extends Block {
    /** Create a container block component with given container, if any */
    constructor(container?: ContainerT | Container);
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: ContainerBlock.Initializer<ContainerT>) => this;
    /** Container element (created by constructor, but may be modified, may be undefined, defaults to a plain `Container` instance; observed) */
    container?: ContainerT;
    /** Overall target height of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component height, may be "auto"); if a height has not been set explicitly, or is set to "auto", then the value is taken from the height of the container; for `LayoutContainer`, a value of "100%" is used if the container's height is also "auto" */
    height: string;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
export namespace ContainerBlock {
    /** Initializer for .with({ ... }) */
    interface Initializer<ContainerT extends Container> extends Block.Initializer {
        /** Property initializer: container component or initializer */
        container: UIValueOrAsync<ComponentFactory<Container> | Container> | ComponentFactory.SpecList2;
    }
}

}

declare module "@typescene/ui/UI/Components/Blocks/Divider" {
import { UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { Block } from "@typescene/ui/UI/Components/Blocks/Block";
/** Represents a divider block element (horizontal line placed between blocks); */
export class Divider extends Block {
    /** Create a new divider with given (optional) properties */
    constructor(color?: string, thickness?: string, margin?: string, insetLeft?: string, insetRight?: string);
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Divider.Initializer) => this;
    /** Line style, e.g. dashed, dotted, double, solid (CSS value, observed) */
    lineStyle: string;
    /** Divider color (observed) */
    color: string;
    /** Divider thickness (CSS value, observed) */
    thickness: string;
    /** Vertical whitespace around divider (CSS value, observed) */
    margin: string;
    /** Horizontal inset on left side (CSS value, observed) */
    insetLeft: string;
    /** Horizontal inset on right side (CSS value, observed) */
    insetRight: string;
    /** Default line color (black, 90% transparency) */
    static COLOR: string;
    /** Default line thickness (1px) */
    static THICKNESS: string;
    /** Default line style (solid) */
    static LINE_STYLE: string;
    /** Default margin (1/2 rem) */
    static MARGIN: string;
}
export namespace Divider {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Block.Initializer {
        /** Property initializer: line style (CSS property) */
        lineStyle?: UIValueOrAsync<string>;
        /** Property initializer: line color (CSS color) */
        color?: UIValueOrAsync<string>;
        /** Property initializer: line weight (CSS length) */
        thickness?: UIValueOrAsync<string>;
        /** Property initializer: space around line (CSS length) */
        margin?: UIValueOrAsync<string>;
        /** Property initializer: left side inset (CSS length) */
        insetLeft?: UIValueOrAsync<string>;
        /** Property initializer: right side inset (CSS length) */
        insetRight?: UIValueOrAsync<string>;
    }
}

}

declare module "@typescene/ui/UI/Components/Blocks/List" {
import { Component } from "@typescene/ui/UI/Components/Component";
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { ComponentRenderer } from "@typescene/ui/UI/Components/ComponentRenderer";
import { ComponentSignal, ComponentSignalHandler } from "@typescene/ui/UI/Components/ComponentSignal";
import { Block } from "@typescene/ui/UI/Components/Blocks/Block";
import { Divider } from "@typescene/ui/UI/Components/Blocks/Divider";
/** Represents a list of blocks */
export class List<BlockT extends Block> extends Block {
    /** Create a list component with given items */
    constructor(items?: Array<BlockT | undefined>);
    /** Method that is called immediately after the renderer for this list is constructed; adds observers for item selection */
    protected beforeFirstRender(renderer: ComponentRenderer<this, any>): void;
    /** Initialize a list factory with given items */
    static withItems<T extends List<any>>(this: {
        new (): T;
        with: typeof List.with;
    }, items: ComponentFactory.SpecList): ComponentFactory<T>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: List.Initializer<BlockT>) => this;
    /** List content (observed) */
    items: Array<BlockT | undefined>;
    /** Current (last) selected item index (base 0), or -1 if no item is selected (observed) */
    selectedIndex: number;
    private _observableSelectedIndex?;
    /** Set to an initializer spec for the Divider component to insert a divider between each element (observed) */
    divider: Divider.Initializer;
    /** Set to a string value to have getFormValues add an ObservableArray with form values of list items */
    name: string;
    /** Deselect all items currently in this list */
    deselectAll(): void;
    /** Select given item (block), and immediately deselect others if `.selectionMode` is `ItemClick` or `ItemFocus`; does _not_ check if the item is included in `.items` at all for performance reasons */
    selectItem(item: BlockT | undefined): void;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
    /** Returns an object containing all current values of input elements (observable) */
    getFormValues(result?: {}): {};
    /** Set all input values by element name */
    setFormValues(values: any): void;
    /** Signal emitted when the list selection changes, while displayed on screen */
    readonly SelectionChange: ComponentSignal.Emittable<List.ItemEvent<any>, typeof List.SelectionSignal>;
    private _dividers;
}
export namespace List {
    /** Initializer for .with({ ... }) */
    interface Initializer<BlockT extends Block> extends Block.Initializer {
        /** Property initializer: list of items */
        items?: ComponentFactory.SpecList;
        /** Divider initializer spec */
        divider?: Divider.Initializer;
        /** Property initializer: (last) selected item index */
        selectedIndex?: UIValueOrAsync<number>;
        /** Property initializer: form values list name */
        name?: string;
        /** Signal initializer: method name or handler */
        SelectionChange?: string | ListSelectionHandler<BlockT>;
    }
    /** Data that is emitted after the item selection of a list component changes */
    interface ItemEvent<T extends Block> {
        /** The target item index */
        index: number;
        /** The target item */
        item?: T;
    }
    /** Signal that is emitted when a list selection event occurs */
    class SelectionSignal<T extends Block> extends ComponentSignal<ItemEvent<T>> {
    }
}
/** Constructor for a list selection event handler */
export class ListSelectionHandler<T extends Block> extends ComponentSignalHandler<List.ItemEvent<T>, typeof List.SelectionSignal> {
}

}

declare module "@typescene/ui/UI/Components/Blocks/NavList" {
import { Container } from "@typescene/ui/UI/Components";
import { Component } from "@typescene/ui/UI/Components/Component";
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { ComponentRenderer } from "@typescene/ui/UI/Components/ComponentRenderer";
import { ComponentSignalHandler, ComponentSignal } from "@typescene/ui/UI/Components/ComponentSignal";
import { TextLabelFactory } from "@typescene/ui/UI/Components/TextLabelFactory";
import { Block } from "@typescene/ui/UI/Components/Blocks/Block";
/** Represents a list of tabs or links */
export class NavList extends Block {
    /** Create a navigation list component */
    constructor(navItems?: NavList.NavItem[], type?: NavList.Type, selectedIndex?: number);
    /** Method that is called immediately after the renderer for this component is constructed; adds observers for nav item selection */
    protected beforeFirstRender(renderer: ComponentRenderer<this, any>): void;
    /** Initialize a nav list factory with given items */
    static withItems<T extends NavList>(this: {
        new (): T;
        with: typeof NavList.with;
    }, navItems: NavList.NavItem[]): ComponentFactory<T>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: NavList.Initializer) => this;
    /** Nav labels, icons, and badges (observed) */
    navItems: NavList.NavItem[];
    /** Space reserved for icons (rem units), if > 0 (observed) */
    remGutter: number;
    /** Index of selected nav item (base 0), or -1 if no selection (observed); does not automatically activate nav item targets; to do so, use the `.activate(...)` function instead */
    selectedIndex: number;
    private _observableSelectedIndex?;
    /** Key (string value) of selected item, if any (read-only, observable) */
    readonly selectedKey: string | undefined;
    /** Type of nav: tabs or pills, inline or stacked; default tabs (observed) */
    type: NavList.Type;
    /** Set to true to fill all horizontal space */
    justified: boolean;
    /** Select nav item by index or key, display associated container if any, and/or start associated activity if any; returns this */
    activate(selection: number | string): this;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
    /** Signal emitted when the selected nav item changes, while displayed on screen */
    readonly NavChange: ComponentSignal.Emittable<NavList.SelectionEvent, typeof NavList.SelectionSignal>;
    /** Container block that contains the container for currently selected item, if any */
    private _containerBlock;
    /** Factory UID of the factory that created the current container, or undefined if container was not created using a factory */
    private _factoryUID?;
    /** Activation instance, with injected methods */
    private _activation;
}
export namespace NavList {
    /** Contains injectable methods for activating targets and querying activation state; instantiated by `NavList` */
    class Activation {
        /** Injectable method to activate given target (e.g. URL, or Activity instance or class); default ony handles URLs, `Application` instance injects more functionality here */
        activate(target: any): void;
        /** Injectable method that returns true (observable) if and when given target matches the current target, i.e. URL/path matches, or activity/class matches current activity or one of its parent activities; this method is called from within an observable context to be able to observe changes to target states */
        isActive(target: any): boolean;
    }
    /** Represents an item in a navigation list (tab or link) */
    interface NavItem {
        /** Text label */
        label?: string | TextLabelFactory;
        /** Icon (see `Label` component) */
        icon?: string;
        /** Badge text */
        badge?: string;
        /** Key (identifier string) of the item, used to populate `NavList/selectedKey` */
        key?: string;
        /** Container to be displayed below tabs/links when this item is selected */
        container?: Container | ComponentFactory<Container>;
        /** URL/path string, or (App module) `Activity` instance or `Activity` class that will be activated when this item is selected; also, the item will be automatically selected if/when its target is active (i.e. URL/path matches, or activity/class matches current activity or one of its parent activities) */
        target?: any;
    }
    /** NavList display type */
    enum Type {
        /** Display as a row of tabs */
        Tabs = 0,
        /** Display as a row of pills */
        Pills = 1,
        /** Display as a list of pills */
        StackedPills = 2,
    }
    /** Initializer for .with({ ... }) */
    interface Initializer extends Block.Initializer {
        /** Property initializer: navlist items */
        navItems?: UIValueOrAsync<NavList.NavItem[]>;
        /** Property initializer: initial item index */
        selectedIndex?: UIValueOrAsync<number>;
        /** Initializer: activate item automatically, by index or key */
        activate?: number | string;
        /** Property initializer: nav display type */
        type?: UIValueOrAsync<NavList.Type>;
        /** Property initializer: true to fill all horizontal space */
        justified?: UIValueOrAsync<boolean>;
        /** Signal initializer: method name or handler */
        NavChange?: string | NavListSelectionHandler;
    }
    /** Data that is emitted when a navlist's selection changes */
    interface SelectionEvent {
        /** The new selection index */
        index: number;
        /** The new selection key, if any */
        key?: string;
        /** The container to be displayed, if any */
        container?: Container;
    }
    /** Signal that is emitted when a navlist's selection changes */
    class SelectionSignal extends ComponentSignal<SelectionEvent> {
    }
}
/** Constructor for a navlist selection event handler */
export class NavListSelectionHandler extends ComponentSignalHandler<NavList.SelectionEvent, typeof NavList.SelectionSignal> {
}

}

declare module "@typescene/ui/UI/Components/Blocks/Row" {
import { ControlElement } from "@typescene/ui/UI/Components";
import { Component } from "@typescene/ui/UI/Components/Component";
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { Block } from "@typescene/ui/UI/Components/Blocks/Block";
/** Represents a row containing control elements placed horizontally */
export class Row extends Block {
    /** Create a row block with given content, if any */
    constructor(content?: ControlElement[]);
    /** Initialize a row factory with given content */
    static withContent<T extends Row>(this: {
        new (): T;
        with: typeof Row.with;
    }, content: ComponentFactory.SpecList): ComponentFactory<T>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Row.Initializer) => this;
    /** Default control component spacing (CSS length) */
    static CONTROL_SPACING: string;
    /** Array of elements that go into this row (observed) */
    content: Array<ControlElement | undefined>;
    /** Spacing between elements (CSS value, observed), defaults to `.CONTROL_SPACING` */
    spacing: string;
    /** Vertical spacing (margin) for this row (CSS value, observed), defaults to `.spacing` if undefined/blank; not applicable if `.height` is set */
    verticalSpacing?: string;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
export namespace Row {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Block.Initializer {
        /** Property initializer: list of control elements */
        content?: ComponentFactory.SpecList;
        /** Property initializer: spacing around controls */
        spacing?: UIValueOrAsync<string>;
        /** Property initializer: vertical spacing above and below controls */
        verticalSpacing?: UIValueOrAsync<string>;
    }
}
/** Represents a row containing control elements placed horizontally, with spacing set to 0 (no margin) */
export class CloseRow extends Row {
    spacing: string;
    verticalSpacing: string;
}
/** A row element with components aligned to the right */
export class OppositeRow extends Row {
}
/** A row element with components aligned in the center */
export class CenterRow extends Row {
}

}

declare module "@typescene/ui/UI/Components/Blocks/Table" {
import * as Async from "@typescene/async";
import { ControlElement } from "@typescene/ui/UI/Components";
import { Component } from "@typescene/ui/UI/Components/Component";
import { ComponentFactory } from "@typescene/ui/UI/Components/ComponentFactory";
import { Block } from "@typescene/ui/UI/Components/Blocks/Block";
import { TableRow, TableHeader } from "@typescene/ui/UI/Components/Blocks/TableRow";
/** Represents a table block component */
export class Table<TableRowT extends TableRow> extends Block {
    /** Create a table with given header and rows, if any */
    constructor(headerColumns?: Array<string | ControlElement | Block>, widths?: string[], rows?: TableRowT[] | Async.ObservableArray<TableRowT>);
    /** Initialize a table factory with given rows */
    static withRows<T extends Table<any>>(this: {
        new (): T;
        with: typeof Table.with;
    }, rows: ComponentFactory.SpecList2TCol): ComponentFactory<T>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Table.Initializer) => this;
    /** Header row; not rendered if undefined, or does not contain columns, OR if table itself has no rows (observed) */
    header?: TableHeader;
    /** List of rows; each row should have the same number of columns (observed) */
    rows: Array<TableRowT | undefined>;
    /** Set to a string value to have getFormValues add an ObservableArray with form values of table rows */
    name?: string;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
    /** Returns an object containing all current values of input elements (observable) */
    getFormValues(result?: {}): {};
    /** Set all input values by element name */
    setFormValues(values: any): void;
}
export namespace Table {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Block.Initializer {
        /** Property initializer: list of rows */
        rows: ComponentFactory.SpecList2TCol;
        /** Property initializer: header row */
        header?: ComponentFactory.SpecEltOrListTCol;
        /** Property initializer: form values list name */
        name?: string;
    }
}

}

declare module "@typescene/ui/UI/Components/Blocks/TableRow" {
import { Style } from "@typescene/ui/UI/Style";
import { ControlElement } from "@typescene/ui/UI/Components";
import { Component } from "@typescene/ui/UI/Components/Component";
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { Block } from "@typescene/ui/UI/Components/Blocks/Block";
/** Represents a row within a `Table` component */
export class TableRow extends Block {
    /** Create a table row with given columns, if any */
    constructor(columns?: Array<string | ControlElement | Block>, widths?: string[], styles?: Array<Style | Style.StyleSet>);
    /** Initialize a table row/header factory with given columns */
    static withColumns<T extends TableRow>(this: {
        new (): T;
        with: typeof TableRow.with;
    }, columns: ComponentFactory.SpecListTCol): ComponentFactory<T>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: TableRow.Initializer) => this;
    /** Column content as strings, control elements, or blocks (observed) */
    columns: Array<string | ControlElement | Block | undefined>;
    /** Column widths for all columns (CSS values, observed) */
    widths: Array<string | undefined>;
    /** Additional styles for all columns (observed) */
    styles: Array<Style | Style.StyleSet | undefined>;
    /** Row index (base 0) the last time this row was rendered, or -1 (observable) */
    rowIndex: number;
    /** Returns an array of directly contained components */
    getChildren(): Component[];
}
export namespace TableRow {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Block.Initializer {
        /** Property initializer: content of all columns, as strings, control elements, or blocks */
        columns: ComponentFactory.SpecListTCol;
        /** Property initializer: widths of all columns */
        widths?: UIValueOrAsync<Array<string | undefined>>;
        /** Property initializer: additional styles for all columns */
        styles?: UIValueOrAsync<Array<Style | Style.StyleSet | undefined>>;
    }
}
/** A table header at the top of a table */
export class TableHeader extends TableRow {
    /** Automatic selection management mode: table header rows are not selectable */
    selectionMode: Component.SelectionMode;
    /** Automatic focus management mode: table header rows are not focusable */
    focusMode: Component.FocusMode;
}

}

declare module "@typescene/ui/UI/Components/Blocks/TreeList" {
import { Component } from "@typescene/ui/UI/Components/Component";
import { ComponentFactory } from "@typescene/ui/UI/Components/ComponentFactory";
import { ComponentRenderer } from "@typescene/ui/UI/Components/ComponentRenderer";
import { ComponentSignal, ComponentSignalHandler } from "@typescene/ui/UI/Components/ComponentSignal";
import { Block } from "@typescene/ui/UI/Components/Blocks/Block";
/** Represents a hierarchical list of blocks */
export class TreeList<BlockT extends TreeList.BlockItem> extends Block {
    /** Create a tree list component with given items */
    constructor(items?: Array<BlockT | undefined>);
    /** Method that is called immediately after the renderer for this list is constructed; adds observers for item selection */
    protected beforeFirstRender(renderer: ComponentRenderer<this, any>): void;
    /** Initialize a list factory with given items */
    static withItems<T extends TreeList<TreeList.BlockItem>>(this: {
        new (): T;
        with: typeof TreeList.with;
    }, items: ComponentFactory.SpecList): ComponentFactory<T>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: TreeList.Initializer<BlockT>) => this;
    /** Hierarchical list content (observed); items can use the `TreeList.BlockItem` interface to provide sub content, see e.g. `TreeListRow` */
    items: Array<BlockT | undefined>;
    /** Select given item (block), and immediately deselect others if `.selectionMode` is `ItemClick` or `ItemFocus`; does _not_ check if the item is included in `.items` at all for performance reasons */
    selectItem(item: BlockT | undefined): void;
    /** Key (string value) of selected item, if any (observable); see `TreeList.BlockItem/key`; if set to a string value, all items in the hierarchy will be checked for a matching key, and selected or deselected; for selected items, parent items will be expanded automatically; input focus will be removed from deselected items as well, but selected items are not focused automatically */
    selectedKey: string | undefined;
    /** Observable used by `selectedKey` setter to watch for changes to list items if key was not found yet; to be cleared when selection changes again */
    private _selectedKeySetter;
    /** Returns an array of directly contained components (observable); i.e. a flattened list of all _visible_ tree list items */
    getChildren(): Component[];
    /** Signal emitted when the list selection changes, while displayed on screen */
    readonly SelectionChange: ComponentSignal.Emittable<TreeList.ItemEvent<BlockT>, typeof TreeList.SelectionSignal>;
    /** Signal emitted when a tree list item is collapsed, while displayed on screen */
    readonly ItemCollapsed: ComponentSignal.Emittable<TreeList.ItemEvent<any>, typeof TreeList.FoldSignal>;
    /** Signal emitted when a tree list item is expanded, while displayed on screen */
    readonly ItemExpanded: ComponentSignal.Emittable<TreeList.ItemEvent<any>, typeof TreeList.FoldSignal>;
    /** Flattened observable array, derived from `.items` property */
    private _flattened?;
}
export namespace TreeList {
    /** Initializer for .with({ ... }) */
    interface Initializer<BlockT extends Block> extends Block.Initializer {
        /** Property initializer: nested list of items */
        items?: ComponentFactory.SpecList;
        /** Signal initializer: method name or handler */
        SelectionChange?: string | TreeListSelectionHandler<BlockT>;
        /** Signal initializer: method name or handler */
        ItemCollapsed?: string | TreeListFoldHandler<BlockT>;
        /** Signal initializer: method name or handler */
        ItemExpanded?: string | TreeListFoldHandler<BlockT>;
    }
    /** Represents a `Block` component with optional properties that define the hierarchical structure used by `TreeList` */
    interface BlockItem extends Block {
        /** Optional key (identifier string) of the item, used to populate `TreeList/selectedKey` */
        key?: string;
        /** Optional flag, set to true to collapse the hierarchy below this item; this property should be observable to update rendered components asynchronously */
        collapsed?: boolean;
        /** Optional (observable) array containing tree list items to be displayed below this item; this property should be observable to update rendered components asynchronously */
        treeListItems?: Array<TreeList.BlockItem | undefined>;
    }
    /** Data that is emitted after the item selection of a tree list component changes, or when a tree list item is collapsed/expanded */
    interface ItemEvent<T extends TreeList.BlockItem> {
        /** The newly selected item */
        item?: T;
        /** The key (string value) of the newly selected item, if any */
        key?: string;
    }
    /** Signal that is emitted when a tree list selection event occurs */
    class SelectionSignal<T extends TreeList.BlockItem> extends ComponentSignal<ItemEvent<T>> {
    }
    /** Signal that is emitted when a tree list item is collapsed or expanded */
    class FoldSignal<T extends TreeList.BlockItem> extends ComponentSignal<ItemEvent<T>> {
    }
}
/** Constructor for a tree list selection event handler */
export class TreeListSelectionHandler<T extends TreeList.BlockItem> extends ComponentSignalHandler<TreeList.ItemEvent<T>, typeof TreeList.SelectionSignal> {
}
/** Constructor for a tree list fold (collapse/expand) event handler */
export class TreeListFoldHandler<T extends TreeList.BlockItem> extends ComponentSignalHandler<TreeList.ItemEvent<T>, typeof TreeList.FoldSignal> {
}

}

declare module "@typescene/ui/UI/Components/Component" {
import * as Async from "@typescene/async";
import { Animation } from "@typescene/ui/UI/Animation";
import { Style } from "@typescene/ui/UI/Style";
import { ActionHandler, ComponentSignal, DragEvent, DragEventSignal, DragHandler, KeyEventSignal, KeyHandler, KeyboardEvent, PointerEvent, PointerEventSignal, PointerHandler } from "@typescene/ui/UI/Components/ComponentSignal";
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { ComponentRenderHandler, ComponentRenderSignal, ComponentRenderer } from "@typescene/ui/UI/Components/ComponentRenderer";
/** Component base class for every part of the user interface */
export abstract class Component extends Async.ObservableObject {
    /** Abstract constructor with any number of arguments */
    constructor(...args: any[]);
    /** Returns a component factory for this component type, with given (observable) property values; the result is an instance of `ComponentFactory`, which doubles as a pre-initialized component constructor; this method is only available on component classes that provide a parameterless constructor */
    static with: <T extends Component, InitializerT>(this: {
        new (): {
            initializeWith(initializer: InitializerT): T;
        };
    }, values: InitializerT) => ComponentFactory<T>;
    /** Initializes this instance with given properties; returns this */
    initializeWith: (values: Component.Initializer) => this;
    /** Force one-time initialization of this component, e.g. apply properties from the static property marked with the `@initializer` decorator, if any; called automatically just before rendering (unobserved), but can also be invoked manually if the initialized properties are required earlier, e.g. at the end of a constructor; only returns true if this instance was not already initialized */
    initialize(): boolean;
    /** True if this component has been initialized (synchronous) */
    private _initialized?;
    /** Returns a new component signal class specific to this component, with optional signal base class which must derive from ComponentSignal; can be used to define custom signals in a component constructor or public property initializer (or memoized get-accessor for lazy initialization); sets static property `ComponentSignal.component` of the derived signal class to the component instance, as well as any other static properties given */
    protected defineComponentSignal<DataT, SignalT extends typeof ComponentSignal>(base?: SignalT & (new (data: DataT) => ComponentSignal<DataT>), properties?: {}): ComponentSignal.Emittable<DataT, SignalT>;
    /** Identifier string (optional), may be set by component factory constructor, and used with .getComponentById(...) */
    id: string;
    /** Globally unique component identifier */
    readonly uid: string;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
    /** Returns a list of currently selected directly contained components, in order of selection (observable) */
    getSelectedChildren(): Component[];
    /** Returns the last selected directly contained component (observable); evaluated asynchronously if automatic selection management mode is `ItemClick` or `ItemFocus`, otherwise evaluated synchronously from current selection status of child components */
    getLastSelectedChild(): Component | undefined;
    /** Returns the nearest matching child element with given ID, if any (observable) */
    getComponentById(id: string): Component | undefined;
    /** Returns the nearest matching child element with given ID _and_ that is an instance of given class, if any (observable) */
    getComponentById<C extends Component>(id: string, componentClass: typeof Component & {
        new (...p: any[]): C;
    }): C | undefined;
    /** Returns all (recursive) child components that are an instance of given class (observable) */
    getComponentsByType<C extends Component>(componentClass: {
        new (...p: any[]): C;
    }): C[];
    /** Returns an object containing all current values of input elements (observable) */
    getFormValues(result?: {}): any;
    /** Set all input values by element name */
    setFormValues(values: any): void;
    /** Animation(s) to be played during the lifetime of this component on screen; initially undefined */
    animations?: Component.Animations;
    /** Play given animation on this component; returns the animation control instance, which can be used to stop the animation manually; given callback is called asynchronously after the animation completes */
    animate<AnimationT extends Animation>(animation: AnimationT, continuous?: boolean, after?: () => void): Animation.AnimationControl<AnimationT>;
    /** Play animation on this component (from `.animations`, by identifier); if found, returns the animation control instance, which can be used to stop the animation manually; given callback is called asynchronously after the animation completes */
    animate(animation: string, continuous?: boolean, after?: () => void): Animation.AnimationControl<Animation> | undefined;
    /** Options for rendering this component (not observable); initially undefined */
    renderOptions?: ComponentRenderer.RenderOptions;
    /** Primary renderer class for this component; injected globally on the component (sub) class, but can be overwritten by assigning to this property (observable) */
    protected Renderer: typeof ComponentRenderer;
    /** Wait for this component to be rendered and return a promise for its output (value of `.out`), unless the component is already rendered, in which case this method returns a resolved promise for the last rendered output; never forces the component to be rendered */
    getRenderedOutputAsync(): PromiseLike<ComponentRenderer.Output<this, any>>;
    /** Returns the last rendered output for this component, if any (value of `.out`); does not trigger a render */
    getLastRenderedOutput(): ComponentRenderer.Output<this, any> | undefined;
    /** Rendered output for this component (observable); retrieving this value triggers a render operation, if it was not already subscribed to, e.g. if the component is displayed on screen; the renderer is lazily constructed from the class reference injected into the `.Renderer` property */
    readonly out: ComponentRenderer.Output<this, any> | undefined;
    /** Render this component synchronously, always updating any existing rendered output; this method should _not_ be used unless changes may have occurred outside of the observable context, otherwise read the value from `.out`, include it on a `Page`, or use the `.display()` method where available */
    render(): ComponentRenderer.Output<this, any> | undefined;
    /** Signal emitted after updating DOM (render) */
    readonly Rendered: ComponentSignal.Emittable<ComponentRenderer.Output<any, any>, typeof ComponentRenderSignal>;
    /** Current renderer instance, created upon access */
    private readonly _renderer;
    /** Method that is called immediately after the renderer for this component is constructed; override this method (and invoke `super.beforeFirstRender`) to be able to call or inject renderer methods before this component is first rendered */
    protected beforeFirstRender(renderer: ComponentRenderer<this, any>): void;
    /** Helper method to watch and apply list focus mode on renderer instance */
    private _watchFocusMode(renderer);
    /** Helper method to watch and apply selection mode on renderer instance */
    private _watchSelectionMode(renderer);
    /** Helper method to observe selected child component(s), and deselect all except component selected latest; also overrides selection mode for components where this property is undefined; returns an observable for the single (last) selected component */
    private _observeSingleSelection(setSelectionMode);
    /** Observable value containing the last selected component, either computed or set asynchronously if automatic selection management mode is `ItemClick` or `ItemFocus` */
    private _lastSelectionAsync?;
    /** Add a new style override to this component class (and derived classes); does not have any effect on existing component instances, but changes to previously added style overrides are always observed; returns given style instance */
    static addStyleOverride(style: Style): Style;
    /** Read-only reference to an instance of `Style`, encapsulating CSS styles and classes for this component; for extensible component classes, do not override this property but use static method `.addStyleOverride(...)` instead */
    readonly style: Style;
    /** Returns the current dimensions for this component, in logical (CSS) pixel units; may return 0x0 if this component is not yet displayed on screen (i.e. use the `.Rendered` signal and/or a timeout to obtain accurate results) */
    getActualDimensions(): {
        width: number;
        height: number;
    };
    /** Overall target height of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component height, may be "auto") */
    height: string;
    /** Overall target width of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component width, may be "auto") */
    width: string;
    /** Set to a number between 0 and 1 to add a drop shadow to this component (shadow "depth" of 1 creates the illusion of a component lifted off the canvas the furthest, 0 means no shadow at all; observable, directly adds shadow effect to `.style`) */
    shadowEffect: number;
    /** Override the drop shadow "depth" value while mouse cursor is hovering over this component, with given number between 0 and 1 */
    addShadowEffectOnHover(d: number): void;
    /** Override the drop shadow "depth" value while this component or a child component has input focus, with given number between 0 and 1 */
    addShadowEffectOnFocus(d: number): void;
    /** Set to true to hide this component (observable, directly modifies hidden state of `.style` and plays show/hide animations) */
    hidden: boolean;
    _hidden: boolean;
    /** Set to true to display this component in a selected state (observable, directly modifies selected state of `.style` and plays select/deselect animations) */
    selected: boolean;
    private _selected;
    /** Automatic selection management mode */
    selectionMode?: Component.SelectionMode;
    /** Last selection order number, assigned when selected */
    private _selectionOrder;
    /** Automatic focus management mode */
    focusMode?: Component.FocusMode;
    /** True if this component _or_ a child component has input focus, false otherwise; set to true to focus the component itself, if and when available (throws an exception if this component is unable to receive input focus); set to false to remove focus from this component */
    hasFocus: boolean;
    /** Connect Focus and Blur signal handlers to maintain `_liveFocus` and `hasFocus` */
    private _connectFocus();
    /** True if the mouse cursor is hovering over this component, false otherwise; evaluated lazily using `.MouseEnter` and `.MouseLeave`, value is `false` initially until first signal is emitted after this property has been read once */
    readonly hoverState: boolean;
    /** Platform focus state, set by Focus/Blur signal handlers */
    private _liveFocus;
    /** Platform hover state, set by MouseEnter/Leave signal handlers */
    private _liveHover?;
    /** Signal emitted when this component _or_ a child component is clicked, touched, or otherwise activated; captured from containers down to contained components, not consumed */
    readonly Click: ComponentSignal.Emittable<PointerEvent, typeof PointerEventSignal>;
    /** Signal emitted asynchronously after this component _or_ a child component is clicked, touched, or otherwise activated; propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly Clicked: ComponentSignal.Emittable<PointerEvent, typeof PointerEventSignal>;
    /** Signal emitted when this component _or_ a child component is double-clicked; captured from containers down to contained components, not consumed */
    readonly DoubleClick: ComponentSignal.Emittable<PointerEvent, typeof PointerEventSignal>;
    /** Signal emitted asynchronously after this component _or_ a child component is double-clicked; propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly DoubleClicked: ComponentSignal.Emittable<PointerEvent, typeof PointerEventSignal>;
    /** Signal emitted when a mouse button is pressed down, or a touch occurs, on this component _or_ a child component; captured from containers down to contained components, not consumed */
    readonly Press: ComponentSignal.Emittable<PointerEvent, typeof PointerEventSignal>;
    /** Signal emitted asynchronously after a mouse button is pressed down, or a touch occurs, on this component _or_ a child component; propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly Pressed: ComponentSignal.Emittable<PointerEvent, typeof PointerEventSignal>;
    /** Signal emitted when the cursor begins to hover over this component; captured from containers down to contained components, not consumed */
    readonly MouseEnter: ComponentSignal.Emittable<PointerEvent, typeof PointerEventSignal>;
    /** Signal emitted when the cursor has left this component; captured from containers down to contained components, not consumed */
    readonly MouseLeave: ComponentSignal.Emittable<PointerEvent, typeof PointerEventSignal>;
    /** Signal emitted when a context menu is requested for this component or a child component (usually by right-clicking); captured from containers down to contained components, not consumed */
    readonly MouseContextMenu: ComponentSignal.Emittable<PointerEvent, typeof PointerEventSignal>;
    /** Signal emitted when a key is pressed down (while this component _or_ a child component is focused); captured from containers down to contained components, not consumed */
    readonly KeyDown: ComponentSignal.Emittable<KeyboardEvent, typeof KeyEventSignal>;
    /** Signal emitted after a key is pressed (while this component _or_ a child component is focused); captured from containers down to contained components, not consumed */
    readonly KeyPress: ComponentSignal.Emittable<KeyboardEvent, typeof KeyEventSignal>;
    /** Signal emitted when this component _or_ a child component receives focus; captured from containers down to contained components, not consumed */
    readonly Focus: ComponentSignal.Emittable<any, typeof ComponentSignal>;
    /** Signal emitted when this component _or_ a child component loses focus; captured from containers down to contained components, not consumed */
    readonly Blur: ComponentSignal.Emittable<any, typeof ComponentSignal>;
    /** Signal emitted asynchronously after this component receives focus; propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly FocusGained: ComponentSignal.Emittable<any, typeof ComponentSignal>;
    /** Signal emitted asynchronously after this component loses focus, and only if `.FocusGained` was emitted previously; propagates from child components to parents, not consumable */
    readonly FocusLost: ComponentSignal.Emittable<any, typeof ComponentSignal>;
    /** Signal emitted when this component _or_ a child component commences a drag operation; captured from containers down to contained components, not consumed */
    readonly DragStart: ComponentSignal.Emittable<DragEvent, typeof DragEventSignal>;
    /** Signal emitted when a drag operation begins to hover over this component; captured from containers down to contained components, not consumable */
    readonly DragEnter: ComponentSignal.Emittable<DragEvent, typeof DragEventSignal>;
    /** Signal emitted when a drag operation has left this component; captured from containers down to contained components, not consumable */
    readonly DragLeave: ComponentSignal.Emittable<DragEvent, typeof DragEventSignal>;
    /** Signal emitted when this element or a child element is the target of a drop after a drag operation; captured from containers down to contained components, not consumed */
    readonly DragDrop: ComponentSignal.Emittable<DragEvent, typeof DragEventSignal>;
    /** Helper function to create a key event signal */
    private _makeKeyEvent(key);
    /** Signal emitted after the enter key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly EnterKeyPressed: ComponentSignal.Emittable<KeyboardEvent, typeof KeyEventSignal>;
    /** Signal emitted after the space bar is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly SpaceBarPressed: ComponentSignal.Emittable<KeyboardEvent, typeof KeyEventSignal>;
    /** Signal emitted after the backspace key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly BackspaceKeyPressed: ComponentSignal.Emittable<KeyboardEvent, typeof KeyEventSignal>;
    /** Signal emitted after the forward-delete key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly DeleteKeyPressed: ComponentSignal.Emittable<KeyboardEvent, typeof KeyEventSignal>;
    /** Signal emitted after the escape key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly EscapeKeyPressed: ComponentSignal.Emittable<KeyboardEvent, typeof KeyEventSignal>;
    /** Signal emitted after the left arrow/d-pad key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly ArrowLeftKeyPressed: ComponentSignal.Emittable<KeyboardEvent, typeof KeyEventSignal>;
    /** Signal emitted after the up arrow/d-pad key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly ArrowUpKeyPressed: ComponentSignal.Emittable<KeyboardEvent, typeof KeyEventSignal>;
    /** Signal emitted after the right arrow/d-pad key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly ArrowRightKeyPressed: ComponentSignal.Emittable<KeyboardEvent, typeof KeyEventSignal>;
    /** Signal emitted after the down arrow/d-pad key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly ArrowDownKeyPressed: ComponentSignal.Emittable<KeyboardEvent, typeof KeyEventSignal>;
}
export namespace Component {
    /** Specification of which animations to play during the lifetime of a component on screen (can be extended for sub component types) */
    interface Animations {
        /** Played when component is displayed or added to a displayed parent component */
        appear?: Animation;
        /** Played when component is removed from the screen */
        disappear?: Animation;
        /** Played when component is shown (set `hidden` to false) */
        show?: Animation;
        /** Played when component is hidden (set `hidden` to true) */
        hide?: Animation;
        /** Played when component is selected (set `selected` to true) */
        select?: Animation;
        /** Played when component is deselected (set `selected` to false) */
        deselect?: Animation;
        [name: string]: Animation | undefined;
    }
    /** Options for automatic focus management */
    enum FocusMode {
        /** Unable to focus this component */
        None = 0,
        /** Click or touch to focus */
        Click = 1,
        /** Click, touch, or use keyboard (tab key) to focus */
        Auto = 2,
        /** Focus a child component on click, touch, or up/down arrow key press; child components with focus mode `None` are ignored */
        Items = 3,
    }
    /** Options for automatic selection management */
    enum SelectionMode {
        /** Unable to select this component */
        None = 0,
        /** Focus to select */
        Focus = 1,
        /** Click or touch, or use space bar (while focused) to select */
        Click = 2,
        /** Click or touch, or use space bar (while focused) to toggle selection */
        Toggle = 3,
        /** Select _one_ child component on click or touch; set selection mode of child components to `Click` if undefined */
        ItemClick = 4,
        /** Select _one_ child component on focus; set selection mode of child components to `Focus` if undefined; to be combined with focus mode `Items` for directional keyboard navigation */
        ItemFocus = 5,
        /** Toggle selection on child components on click or touch, or space bar (while focused): set selection mode of child components to `Toggle` if undefined */
        ItemToggle = 6,
    }
    /** Initializer for .with({ ... }) */
    interface Initializer {
        /** Identifier, used to add a component reference to the base component (on which .with(...) or .initializeWith(...) was called) as a property with given identifier */
        id?: string;
        /** Style initializer: object or `Style` instance */
        style?: UIValueOrAsync<Style | Style.StyleSet>;
        /** Property initializer: target height (CSS length) */
        height?: UIValueOrAsync<string>;
        /** Property initializer: target width (CSS length) */
        width?: UIValueOrAsync<string>;
        /** Property initializer: 0 (no shadow effect) - 1 (greatest effect) */
        shadowEffect?: UIValueOrAsync<number>;
        /** Shadow effect when hovered over: 0 (no shadow effect) - 1 (greatest effect) */
        shadowEffectOnHover?: number;
        /** Shadow effect when focused component or child: 0 (no shadow effect) - 1 (greatest effect) */
        shadowEffectOnFocus?: number;
        /** Property initializer: true if component should be hidden */
        hidden?: UIValueOrAsync<boolean>;
        /** Property initializer: true if component should be selected */
        selected?: UIValueOrAsync<boolean>;
        /** Property initializer: automatic selection management mode */
        selectionMode?: UIValueOrAsync<SelectionMode>;
        /** Property initializer: true if component should be focused for input */
        hasFocus?: UIValueOrAsync<boolean>;
        /** Property initializer: automatic focus management mode */
        focusMode?: UIValueOrAsync<FocusMode>;
        /** Animations list (not observable, will overwrite all existing ones) */
        animations?: Component.Animations;
        /** Options for rendering this component (not observable) */
        renderOptions?: ComponentRenderer.RenderOptions;
        /** Signal initializer: method name or handler */
        Rendered?: string | ComponentRenderHandler;
        /** Signal initializer: method name or handler */
        Click?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        Clicked?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        DoubleClick?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        DoubleClicked?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        Press?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        Pressed?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        MouseEnter?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        MouseLeave?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        MouseContextMenu?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        KeyDown?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        KeyPress?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        Focus?: string | ActionHandler;
        /** Signal initializer: method name or handler */
        Blur?: string | ActionHandler;
        /** Signal initializer: method name or handler */
        FocusGained?: string | ActionHandler;
        /** Signal initializer: method name or handler */
        FocusLost?: string | ActionHandler;
        /** Signal initializer: method name or handler */
        DragStart?: string | DragHandler;
        /** Signal initializer: method name or handler */
        DragEnter?: string | DragHandler;
        /** Signal initializer: method name or handler */
        DragLeave?: string | DragHandler;
        /** Signal initializer: method name or handler */
        DragDrop?: string | DragHandler;
        /** Signal initializer: method name or handler */
        EnterKeyPressed?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        SpaceBarPressed?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        BackspaceKeyPressed?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        DeleteKeyPressed?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        EscapeKeyPressed?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        ArrowLeftKeyPressed?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        ArrowUpKeyPressed?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        ArrowRightKeyPressed?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        ArrowDownKeyPressed?: string | KeyHandler;
    }
}

}

declare module "@typescene/ui/UI/Components/ComponentFactory" {
import * as Async from "@typescene/async";
import { Binding } from "@typescene/ui/UI/Binding";
import { Component } from "@typescene/ui/UI/Components/Component";
import { TextLabelFactory } from "@typescene/ui/UI/Components/TextLabelFactory";
/** Type definition used by component initializers, that wraps a type as well as the same type within an observable value, promise, or binding */
export type UIValueOrAsync<T> = T | Async.ObservableValue<T> | PromiseLike<T> | Binding<any>;
/** Component factory class: constructor creates and initializes a Component */
export interface ComponentFactory<T extends Component> {
    /** Component class that this factory was created from */
    target: {
        new (): T;
    };
    /** Unique factory identifier */
    uid: string;
    /** Contruct the component with all properties contained in this factory */
    new (): T;
    /** Initializes more properties using given values; returns this */
    with(initializer: any): this;
    /** Creates an instance (same as using constructor, but can be chained) */
    create(): T;
    /** Apply the properties from this factory to the given (existing) component; returns the component itself */
    applyTo(component: T): T;
}
export namespace ComponentFactory {
    /** A factory initializer element (e.g. control element) */
    type SpecElt = UIValueOrAsync<ComponentFactory<Component> | TextLabelFactory | Component | typeof Component | undefined>;
    /** A factory initializer element (e.g. control element) or table content */
    type SpecEltTCol = UIValueOrAsync<ComponentFactory<Component> | TextLabelFactory | Component | typeof Component | string | number | undefined>;
    /** A list of factory initializer elements (e.g. row) */
    type SpecList = UIValueOrAsync<Array<SpecElt>>;
    /** A list of factory initializer elements (e.g. row) or table content */
    type SpecListTCol = UIValueOrAsync<Array<SpecEltTCol>>;
    /** A list of factory initializer elements, or a single element */
    type SpecEltOrList = UIValueOrAsync<SpecElt | Array<SpecElt>>;
    /** A list of factory initializer elements, or a single element; or table content */
    type SpecEltOrListTCol = UIValueOrAsync<SpecEltTCol | Array<SpecEltTCol>>;
    /** A list of (lists of) factory initializer elements */
    type SpecList2 = UIValueOrAsync<Array<SpecEltOrList>>;
    /** A list of (lists of) factory initializer elements or table content */
    type SpecList2TCol = UIValueOrAsync<Array<SpecEltOrListTCol>>;
    /** Choices for the level at which components in (array) properties are expected to be; used by factory to expand/wrap initializer property values before storing them in a property decorated with `applyComponentsArray` or `applyComponentRef` */
    enum CLevel {
        Container = 0,
        Block = 1,
        ControlElement = 2,
        TableRow = 3,
        TableHeader = 4,
    }
    /** _Property decorator_ for a property where values from an initializer spec should be applied as an (observable) array of components of given type (e.g. `Block`, `ControlElement`, `TableRow`); the factory will then expand/wrap regular and observable arrays of objects, factories, classes, or components into the correct type [decorator] */
    function applyComponentsArray(type: ComponentFactory.CLevel): (target: any, key: string) => void;
    /** _Property decorator_ for a property where values from an initializer spec should be applied as a reference to a component of given type (e.g. `Block`, `ControlElement`); the factory will then expand/wrap objects, factories, classes, and components into the correct type [decorator] */
    function applyComponentRef(type: ComponentFactory.CLevel): (target: any, key: string) => void;
    /** _Property decorator_ for a property for which values from an initializer spec should be applied asynchronously (using an `Async.defer(...)` call), instead of being set directly [decorator] */
    function applyAsync(target: any, key: string): void;
    /** _Method decorator_ for the method that should be called to apply the value of an initializer spec property with the given property name; the method should always accept values as well as instances of `Async.ObservableValue` [decorator] */
    function setterFor(initializerPropertyName: string): MethodDecorator;
}
/** _Property decorator_ for the static `initializer` property of a `Component` class, containing a `ComponentFactory` that will be used to initialize every instance before rendering; the factory must be of a compatible type, i.e. result of the static `.with*(...)` method of a parent component class [decorator] */
export function initializer<ComponentT extends Component>(target: {
    new (...args): ComponentT;
}, key: "initializer", descriptor?: TypedPropertyDescriptor<ComponentFactory<ComponentT>>): any;

}

declare module "@typescene/ui/UI/Components/ComponentRenderer" {
import * as Async from "@typescene/async";
import { Component } from "@typescene/ui/UI/Components/Component";
import { ComponentSignal, ComponentSignalHandler } from "@typescene/ui/UI/Components/ComponentSignal";
/** Class that contains the code necessary to render a component; to retrieve rendering output, Component methods only use the `.output` property, which is an ObservableValue instance that is populated using the (protected) `.render` method */
export abstract class ComponentRenderer<ComponentT extends Component, ElementT> {
    /** Create a new renderer instance for given component */
    constructor(component: ComponentT);
    /** The component that this renderer renders */
    readonly component: ComponentT;
    /** An observable value containing the rendered output, if any; used by the Component rendering methods to retrieve output; this property should *not* be overridden, override the protected `.render` method instead and/or use the `.watch` method to add partial rendering code */
    readonly output: Async.ObservableValue<ComponentRenderer.Output<ComponentT, ElementT> | undefined>;
    /** Signal that is emitted after updating `.output` (but not if undefined) and/or when the `updated` promise on the rendered output is resolved */
    readonly Rendered: ComponentSignal.Emittable<ComponentRenderer.Output<ComponentT, ElementT>, typeof ComponentRenderSignal>;
    /** Component renderer function; to be overridden, *must* be a pure function, based on the current `.component` and `.output` properties (otherwise *creating* or *setting* ObservableValue instances should be done within a function that is passed to `unobserved`) */
    protected render(): ComponentRenderer.Output<ComponentT, ElementT> | undefined;
    /** Add a method that will be called (synchronously and asynchronously) from a new observable context, after previously added methods, immediately *after* the `.render` method has run once, along with an optional method that will be called (synchronously, unobserved) with the result of the first method; i.e. observable values used in the first method will be subscribed to while the output is subscribed to, but changes to these values will never trigger re-rendering the entire component -- instead, the second function is invoked; useful for partially updating existing output using a subset of component properties; should be called _before_ rendering takes place */
    watch<T>(getter: (this: this) => T, map?: (this: this, value: T) => void): void;
}
export namespace ComponentRenderer {
    /** Encapsulates output for a rendered component; class type parameters indicate the type of component rendered, and the output type (e.g. HTMLElement) */
    class Output<ComponentT extends Component, ElementT> {
        /** Create a new instance for given component, with given element (should not be undefined) */
        constructor(component: ComponentT, element: ElementT, context?: any);
        /** The component that the output is generated for */
        readonly component: ComponentT;
        /** Reference to the actual output (e.g. DOM element) */
        readonly element: ElementT;
        /** Reference to an element that wraps around the output element, that should be included by the parent element instead (or undefined) */
        wrapper?: ElementT;
        /** Reference to a (sub) element that should be used to register event handlers, if different from main element (otherwise undefined) */
        liveElement?: ElementT;
        /** If defined, a promise that resolves the next time the content of the rendered output element is generated (drawn on screen _if_ the parent output element is also already on screen) */
        updated?: PromiseLike<any>;
        /** Flag that can be used for duck typing */
        isComponentOutput: true;
    }
    /** Options for rendering (child) components */
    interface RenderOptions {
        /** Set to true to force synchronous rendering for this component */
        synchronous?: boolean;
        /** Set to a value in milliseconds to animate _child component_ positioning for the given duration, if possible; only works with lists and tables, and may require synchronous rendering of child components (i.e. set `.synchronous` on list items) */
        animateListItems?: number;
    }
}
/** Signal that is emitted when a component updates its rendered output */
export class ComponentRenderSignal<ComponentT extends Component, ElementT> extends ComponentSignal<ComponentRenderer.Output<ComponentT, ElementT>> {
    static renderer: ComponentRenderer<Component, any>;
}
/** Constructor for a component render event handler */
export class ComponentRenderHandler extends ComponentSignalHandler<ComponentRenderer.Output<Component, any>, typeof ComponentRenderSignal> {
}
/** _Class decorator_, maps the decorated `ComponentRenderer` class to a `Component` class as its primary renderer; the renderer class constructor must have a single argument, being the component to be rendered; overrides previously mapped renderer entirely, to extend super class renderer functionality inject a class that extends the previous renderer class [decorator] */
export function mapComponentRenderer<ComponentT extends Component>(componentClass: typeof Component & {
    new (...args: any[]): ComponentT;
}): (target: typeof ComponentRenderer & (new (component: ComponentT) => ComponentRenderer<ComponentT, any>)) => void;

}

declare module "@typescene/ui/UI/Components/ComponentSignal" {
import * as Async from "@typescene/async";
import { Drag } from "@typescene/ui/UI/Drag";
import { Component } from "@typescene/ui/UI/Components/Component";
/** Signal that is emitted by a component instance as the result of a user action */
export class ComponentSignal<DataT> extends Async.Signal<DataT> {
    /** Component for which this signal will be emitted */
    static readonly component: Component;
}
export namespace ComponentSignal {
    /** Type definition for a callable (emittable) component signal *class*; the type parameters represent handler function arguments: signal payload, and emitted signal base class, which has a static `component` property that refers to the emitting component */
    interface Emittable<T, SignalClassT extends typeof ComponentSignal> extends Async.Signal.Emittable<T, SignalClassT> {
        /** Emit a signal with given value, for the component this signal is attached to */
        (data?: T): void;
        /** Component for which this signal will be emitted */
        readonly component: Component;
    }
}
/** Abstract wrapper for a handler that can connect to signals derived from `ComponentSignal`; used for automatic type inference of signal handlers */
export interface ComponentSignalHandler<DataT, SignalClassT extends typeof ComponentSignal> extends Function {
    /** Call the handler as a function */
    (data?: DataT, src?: SignalClassT): void;
    /** Add this EventHandler as a handler for given event signal */
    connectTo(signal: ComponentSignal.Emittable<DataT, SignalClassT>): Async.SignalConnection;
    /** Always true, for duck typing wrapped handlers */
    isEventHandler: true;
}
/** [implementation] "Constructor" wrapper for a UI signal handler */
export abstract class ComponentSignalHandler<DataT, SignalClassT extends typeof ComponentSignal> {
    constructor(f: (data: DataT, src: SignalClassT) => void);
}
/** Interface definition of a platform agnostic keyboard event */
export interface KeyboardEvent {
    /** True if `alt` key is held down */
    altKey?: boolean;
    /** True if `ctrl` key is held down */
    ctrlKey?: boolean;
    /** True if `meta` key is held down */
    metaKey?: boolean;
    /** True if `shift` key is held down */
    shiftKey?: boolean;
    /** Key code, used with key up/down events */
    keyCode?: number;
    /** Character code (usually ASCII), used with key press events */
    which?: number;
    /** Stop the default action for this event from taking place */
    preventDefault?: () => void;
}
/** Interface definition of a platform agnostic mouse/pointer event */
export interface PointerEvent {
    /** True if `alt` key is held down */
    altKey?: boolean;
    /** True if `ctrl` key is held down */
    ctrlKey?: boolean;
    /** True if `meta` key is held down */
    metaKey?: boolean;
    /** True if `shift` key is held down */
    shiftKey?: boolean;
    /** Mouse button affected: 0 = primary, 2 = secondary */
    button?: number;
    /** Horizontal coordinate relative to the browser window */
    clientX?: number;
    /** Vertical coordinate relative to the browser window */
    clientY?: number;
    /** Stop the default action for this event from taking place */
    preventDefault?: () => void;
}
/** Interface definition of a drag event with payload */
export interface DragEvent {
    /** Event payload */
    detail: Drag.DragEventDetail;
}
/** Constructor for a component signal handler (no event data) */
export class ActionHandler extends ComponentSignalHandler<never, typeof ComponentSignal> {
}
/** Signal that is emitted when a keyboard event occurs */
export class KeyEventSignal extends ComponentSignal<KeyboardEvent> {
}
/** Constructor for a keyboard event handler */
export class KeyHandler extends ComponentSignalHandler<KeyboardEvent, typeof KeyEventSignal> {
}
/** Signal that is emitted when a mouse/pointer event occurs */
export class PointerEventSignal extends ComponentSignal<PointerEvent> {
}
/** Constructor for a mouse/pointer event handler */
export class PointerHandler extends ComponentSignalHandler<PointerEvent, typeof PointerEventSignal> {
}
/** Signal that is emitted when a custom drag event occurs */
export class DragEventSignal extends ComponentSignal<DragEvent> {
}
/** Constructor for a drag event handler */
export class DragHandler extends ComponentSignalHandler<DragEvent, typeof DragEventSignal> {
}

}

declare module "@typescene/ui/UI/Components/Composite/ConfirmationDialog" {
import { TextLabelFactory } from "@typescene/ui/UI/Components/TextLabelFactory";
import { ComponentFactory } from "@typescene/ui/UI/Components/ComponentFactory";
import { ComponentSignal } from "@typescene/ui/UI/Components/ComponentSignal";
import { DialogContainer } from "@typescene/ui/UI/Components";
/** Represents a generic confirmation dialog with Confirm and Cancel options, contains either a single Paragraph component, or a stack initialized with given texts; emits Confirmed signal when confirm button is clicked */
export class ConfirmationDialog extends DialogContainer {
    static initializer: ComponentFactory<DialogContainer>;
    /** Create a confirmation dialog with given text */
    constructor(headerText: string | TextLabelFactory, messageText: string | TextLabelFactory, confirmButtonLabel?: string | TextLabelFactory, cancelButtonLabel?: string | TextLabelFactory);
    /** Create a confirmation dialog with given texts stacked vertically */
    constructor(headerText: string | TextLabelFactory, messageTexts: Array<string | TextLabelFactory>, confirmButtonLabel?: string | TextLabelFactory, cancelButtonLabel?: string | TextLabelFactory);
    /** Dialog header text, if any */
    headerText?: string | TextLabelFactory;
    /** One or more lines of text to be displayed as main content */
    messageText: string | TextLabelFactory | Array<string | TextLabelFactory>;
    /** The confirmation button label (defaults to Confirm) */
    confirmButtonLabel: string | TextLabelFactory;
    /** The cancellation button label (defaults to Cancel) */
    cancelButtonLabel: string | TextLabelFactory;
    /** Signal that is emitted when the confirm button has been clicked */
    readonly Confirmed: ComponentSignal.Emittable<{}, typeof ComponentSignal>;
}

}

declare module "@typescene/ui/UI/Components/Composite/MessageDialog" {
import { TextLabelFactory } from "@typescene/ui/UI/Components/TextLabelFactory";
import { ComponentFactory } from "@typescene/ui/UI/Components/ComponentFactory";
import { DialogContainer } from "@typescene/ui/UI/Components";
/** Represents a generic message dialog with one button to dismiss, contains either a single Paragraph component, or a stack initialized with given texts */
export class MessageDialog extends DialogContainer {
    static initializer: ComponentFactory<DialogContainer>;
    /** Create a message dialog with given text */
    constructor(headerText: string | TextLabelFactory, messageText: string | TextLabelFactory, buttonLabel?: string | TextLabelFactory);
    /** Create a message dialog with given texts stacked vertically */
    constructor(headerText: string | TextLabelFactory, messageTexts: Array<string | TextLabelFactory>, buttonLabel?: string | TextLabelFactory);
    /** Dialog header text, if any */
    headerText?: string | TextLabelFactory;
    /** One or more lines of text to be displayed as main content */
    messageText: string | TextLabelFactory | Array<string | TextLabelFactory>;
    /** The dismiss button label (defaults to Dismiss) */
    buttonLabel: string | TextLabelFactory;
}

}

declare module "@typescene/ui/UI/Components/Composite/Toast" {
import { Animation } from "@typescene/ui/UI/Animation";
import { Block, Row } from "@typescene/ui/UI/Components";
import { ComponentFactory } from "@typescene/ui/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/ui/UI/Components/TextLabelFactory";
/** Represents a toast message that is displayed in the corner of the page */
export class Toast extends Row {
    timeout: number;
    /** Close all toasts currently displayed on the page */
    static closeAll(): void;
    /** Global positioning setting (do not change after first display) */
    static POSITION: Block.OverlayPosition;
    /** Global margin setting, in pixels (do not change after first display) */
    static HORZ_OUTER_MARGIN_PX: number;
    /** Global margin setting, in pixels (do not change after first display) */
    static VERT_OUTER_MARGIN_PX: number;
    /** Global margin setting, in pixels (do not change after first display) */
    static VERT_INNER_MARGIN_PX: number;
    /** Default timeout for new toast messages, in milliseconds (defaults to 4000) */
    static TIMEOUT: number;
    /** Maximum width for toast messages (CSS length) */
    static MAX_WIDTH: string;
    /** Default "appear" animation, added to every new `Toast` instance by the constructor */
    static APPEAR_ANIMATION?: Animation;
    /** Default "disappear" animation, added to every new `Toast` instance by the constructor */
    static DISAPPEAR_ANIMATION?: Animation;
    /** Create a toast message with given content, and optional timeout in ms (default 4000) */
    constructor(content: string | TextLabelFactory | ComponentFactory.SpecElt[], timeout?: number);
    /** Display this toast message on the page */
    display(): this | undefined;
    /** Remove this toast from the page */
    close(): void;
    private _override;
}

}

declare module "@typescene/ui/UI/Components/Composite/TreeListRow" {
import { ArrayBinding } from "@typescene/ui/UI/Binding";
import { Component, CloseRow, TreeList, ControlElement } from "@typescene/ui/UI/Components";
import { ComponentFactory } from "@typescene/ui/UI/Components/ComponentFactory";
/** Represents a tree list row, with an optional list of sub rows; implements the `TreeList.BlockItem` interface */
export class TreeListRow extends CloseRow implements TreeList.BlockItem {
    /** Create an _array_ of tree list row components from the given array of tree item data objects, with given icons and measurements */
    static arrayFromItems(itemData: TreeListRow.ItemData[], openIcon: string, closedIcon: string, remGutter?: number, height?: string): TreeListRow[];
    /** Create a new `ArrayBinding` for given property name/path on the base component, which should contain an array of unique tree item data objects; the binding resolves to an observable array of `TreeListRow` instances; for use in a component initializer; set the `batchSize` argument to a value greater than 0 to create rows in batches for faster initial rendering */
    static arrayFromBinding(sourcePath: string, openIcon: string, closedIcon: string, remGutter?: number, height?: string, batchSize?: number): ArrayBinding<Component>;
    /** Creates a new tree list row for given item data, with given open/closed icon names and measurements; set the `batchSize` argument to a value greater than 0 to create child rows in batches for faster initial rendering */
    constructor(itemData: TreeListRow.ItemData, openIcon: string, closedIcon: string, remGutter?: number, height?: string, batchSize?: number);
    /** Default height for new instances (CSS length, initially 1.75em) */
    static HEIGHT: string;
    /** Default gutter width for new instances (CSS length in rem units, initially 1.5) */
    static REM_GUTTER: number;
    /** Item data for this row (observed as a shallow reference, i.e. item data properties are not automatically observed, but the reference to the object itself is) */
    itemData: TreeListRow.ItemData;
    /** Item key for this row (read-only, taken directly from the `itemData` object; observable) */
    readonly key: string | undefined;
    /** Indent width, i.e. width of space before nested row content, and icon width (CSS length in rem units; observed) */
    remGutter: number;
    /** Name of the icon that is used in front of rows that have a `treeListItems` array and are not collapsed (see `Icon/icon` property on `Icon`; observed) */
    openIcon: string;
    /** Name of the icon that is used in front of rows that have a `treeListItems` array and are currently collapsed (see `Icon/icon` property on `Icon`; observed) */
    closedIcon: string;
    /** Reference to the `TreeListRow` instance that created this row, if any, i.e. the parent row in the visual hierarchy; this property is set automatically by a parent constructor, and by the static methods `arrayFromItems`, and `arrayFromBinding`; otherwise it _must_ be set before rendering */
    treeListRowParent?: TreeListRow;
    /** True if this row is collapsed (defaults to true; observable) */
    collapsed: boolean;
    /** List of rows displayed below this row in the hierarchical structure of a `TreeList` component; automatically generated based on `itemData` and its properties */
    readonly treeListItems: TreeListRow[];
    /** Tree list row content; automatically generated based on `itemData` and its properties */
    readonly content: ControlElement[];
    /** Generate the content factory initializer spec for this row (used as an observable getter) */
    private _getContentSpec();
    /** Generate the observable array that contains `TreeListRow` instances for child items */
    private _getTreeListItems(batchSize?);
    /** Cached indent position 1-n */
    private _indent;
    /** Cached content spec */
    private _contentSpec;
    /** Cached spacer instance */
    private _contentSpecSpacer;
    /** Cached toggle icon instance */
    private _contentSpecToggleIcon;
    /** Cached label instance */
    private _contentSpecLabel;
}
export namespace TreeListRow {
    /** Interface definition of the source data that can be used to construct a `TreeListRow` instance and its children; actual objects may contain more state information such as an instance of a linked (view) model, however either a `content` array or a `name` property is required */
    interface ItemData {
        /** Optional key (identifier string) of the item */
        key?: string;
        /** Row content to be displayed for this item, as a factory initializer spec: an array containing strings, `TextLabelFactory` instances, `Icon` instances or factories, etc */
        content?: ComponentFactory.SpecList;
        /** Item display name, displayed in a `WideLabel` component if `content` is undefined */
        name?: string;
        /** Name of the icon displayed at the start of the row (after the open/closed icon, if any) */
        icon?: string;
        /** (Observable) array of sub items to be displayed; child instances of `TreeListRow` are automatically created for these items upon initialization; if this property is undefined, the tree list row will be displayed as a leaf item; if this array is not observable, the list of sub items will not be updated automatically */
        items?: TreeListRow.ItemData[];
        /** True if the created tree list row should be automatically expanded to reveal sub items when rendered */
        autoExpand?: boolean;
    }
}

}

declare module "@typescene/ui/UI/Components/Containers/Container" {
import { Page } from "@typescene/ui/UI/Page";
import { Block, List } from "@typescene/ui/UI/Components";
import { Component } from "@typescene/ui/UI/Components/Component";
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
/** Represents a container with vertically stacked blocks */
export class Container extends Component {
    /** Create a container with given content, if any */
    constructor(content?: Block[]);
    /** Initialize a container factory with given content */
    static withContent<T extends Container>(this: {
        new (): T;
        with: typeof Container.with;
    }, content: ComponentFactory.SpecList2): ComponentFactory<T>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Container.Initializer) => this;
    /** Array of main content blocks, stacked top to bottom (observed) */
    content: Array<Block | undefined>;
    /** Vertical positioning of main content area within the outer boundaries of the container (observed), defaults to "top" if not defined */
    vertAlign?: "top" | "middle" | "bottom";
    /** Horizontal positioning of main content area within the outer boundaries of the container (observed), defaults to "center" if not defined; may lead to unexpected results if the contained blocks are of different widths */
    horzAlign?: "left" | "center" | "right";
    /** Max width of main content (observed); leave this blank to remove content width limitations */
    maxContentWidth: string;
    /** Set to true to make content within container scrollable; defaults to false (observed) */
    scrollable?: boolean;
    /** Flag that becomes true when the container content is scrolled all the way to the top (observable); scroll position is continuously monitored after this value is read once */
    readonly scrolledToTop: boolean | undefined;
    private _scrolledToTop?;
    /** Flag that becomes true when the container content is scrolled all the way to the bottom, or to the threshold defined by `.scrollBottomThreshold` (observable); scroll position is continuously monitored after this value is read once */
    readonly scrolledToBottom: boolean | undefined;
    private _scrolledToBottom?;
    /** Flag that becomes true when the container content is scrolled all the way to the left (observable); scroll position is continuously monitored after this value is read once */
    readonly scrolledToLeft: boolean | undefined;
    private _scrolledToLeft?;
    /** Flag that becomes true when the container content is scrolled all the way to the right (observable); scroll position is continuously monitored after this value is read once */
    readonly scrolledToRight: boolean | undefined;
    private _scrolledToRight?;
    /** Bottom scroll threshold in pixels away from the bottom of this container: when reached this position, the `.scrolledToBottom` property is set (observed, but does not directly influence current property values); can be used e.g. to trigger lazy loading of list items or trigger footer display */
    scrollBottomThreshold?: number;
    /** Top scroll threshold in pixels away from the top of this container: when reached this position, the `.scrolledToTop` property is set (observed, but does not directly influence current property values); can be used e.g. to trigger lazy loading of list items or trigger header display */
    scrollTopThreshold?: number;
    /** Object with options to be used when displaying this container as a page component, initially undefined (observed) */
    displayOptions?: Page.DisplayOptions;
    /** Returns true if this container contains a List component without items, optionally of given type (observable if used in getter); useful as a shortcut in a getter for .hidden on a "blank-slate" block */
    hasEmptyList(listComponentClass?: typeof List): boolean;
    /** Display this container on screen; fills entire page unless `.displayOptions` is configured otherwise; returns this */
    display(): this;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
/** Represents a container with blocks that are laid out in rows, automatically spanning multiple rows if necessary */
export class FlowContainer extends Container {
}
export namespace Container {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Component.Initializer {
        /** Property initializer: content blocks */
        content?: ComponentFactory.SpecList2;
        /** Property initializer: vertical positioning of main content area ("top", "middle", "bottom") */
        vertAlign?: UIValueOrAsync<string>;
        /** Property initializer: horizontal positioning of main content area ("left", "center", "right") */
        horzAlign?: UIValueOrAsync<string>;
        /** Property initializer: maximum content width */
        maxContentWidth?: UIValueOrAsync<string>;
        /** Property initializer: true for scrollable content area */
        scrollable?: UIValueOrAsync<boolean>;
        /** Property initializer: scroll-top threshold distance in pixels */
        scrollTopThreshold?: UIValueOrAsync<number>;
        /** Property initializer: scroll-bottom threshold distance in pixels */
        scrollBottomThreshold?: UIValueOrAsync<number>;
        /** Property initializer: display options (for use when displayed directly on the page) */
        displayOptions?: Page.DisplayOptions;
        /** Property initializer: true to focus first component on render */
        focusFirst?: UIValueOrAsync<boolean>;
    }
}

}

declare module "@typescene/ui/UI/Components/Containers/DialogContainer" {
import { Animation } from "@typescene/ui/UI/Animation";
import { Page } from "@typescene/ui/UI/Page";
import { Block } from "@typescene/ui/UI/Components";
import { Component } from "@typescene/ui/UI/Components/Component";
import { ComponentFactory } from "@typescene/ui/UI/Components/ComponentFactory";
import { ActionHandler, ComponentSignal } from "@typescene/ui/UI/Components/ComponentSignal";
import { Container } from "@typescene/ui/UI/Components/Containers/Container";
import { TextButton } from "@typescene/ui/UI/Components/Controls/Button";
/** Represents a modal dialog container */
export class DialogContainer extends Container {
    /** Create a new modal dialog with given content, if any */
    constructor(content?: Block[], width?: string);
    /** Default "appear" animation, added to every new DialogContainer instance by the constructor */
    static APPEAR_ANIMATION?: Animation;
    /** Default "disappear" animation, added to every new DialogContainer instance by the constructor */
    static DISAPPEAR_ANIMATION?: Animation;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: DialogContainer.Initializer) => this;
    /** Block to be displayed as a header, may be undefined (observed) */
    header?: Block;
    /** Block to be displayed as a footer, may be undefined (observed) */
    footer?: Block;
    /** Remove the dialog from screen (does not emit or wait for `.Closing` signal, only emits `.Closed`); returns this */
    close(): this;
    /** Use given component as a drag handle for this dialog (and releases handle currently in use; defaults to .header) */
    setDragHandle(handle?: Component): void;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
    /** Object with options to be used when displaying on a page (observed) */
    displayOptions: Page.DisplayOptions;
    /** Signal emitted when user clicks outside dialog, presses esc or clicks DialogContainer.TopCloseButton; if any handler throws an error then the dialog will not close */
    readonly Closing: ComponentSignal.Emittable<void, typeof DialogContainer.CloseSignal>;
    /** Signal emitted when this dialog has been closed */
    readonly Closed: ComponentSignal.Emittable<void, typeof DialogContainer.CloseSignal>;
}
export namespace DialogContainer {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Container.Initializer {
        /** Property initializer: header block */
        header?: ComponentFactory.SpecEltOrList;
        /** Property initializer: footer block */
        footer?: ComponentFactory.SpecEltOrList;
        /** Signal initializer: method name or handler */
        Closing?: string | ActionHandler;
        /** Signal initializer: method name or handler */
        Closed?: string | ActionHandler;
    }
    /** Signal that is emitted when a dialog is closing or has closed */
    class CloseSignal extends ComponentSignal<void> {
    }
    /** Predefined modal close button ("X") control, based on `TextButton` */
    class TopCloseButton extends TextButton {
        /** Create a modal close button ("X") control */
        constructor();
    }
}

}

declare module "@typescene/ui/UI/Components/Containers/DrawerContainer" {
import { Animation } from "@typescene/ui/UI/Animation";
import { Block } from "@typescene/ui/UI/Components";
import { ComponentFactory } from "@typescene/ui/UI/Components/ComponentFactory";
import { DialogContainer } from "@typescene/ui/UI/Components/Containers/DialogContainer";
/** Represents a modal container displayed on the side of the screen */
export class DrawerContainer extends DialogContainer {
    /** Create a drawer component with given content, if any */
    constructor(content?: Block[], width?: string);
    /** Default "appear" animation, added to every new `DrawerContainer` instance by the constructor */
    static APPEAR_ANIMATION?: Animation;
    /** Default "disappear" animation, added to every new `DrawerContainer` instance by the constructor */
    static DISAPPEAR_ANIMATION?: Animation;
    /** Initialize a drawer factory with given properties */
    static with: (values: DialogContainer.Initializer) => ComponentFactory<DrawerContainer>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: DialogContainer.Initializer) => this;
}
/** Represents a modal container displayed on the right hand side of the screen (i.e. DrawerContainer with different alignment and animations) */
export class OppositeDrawerContainer extends DrawerContainer {
    /** Create a drawer component with given content, if any */
    constructor(content?: Block[], width?: string);
    /** Default "appear" animation, added to every new `OppositeDrawerContainer` instance by the constructor */
    static APPEAR_ANIMATION?: Animation;
    /** Default "disappear" animation, added to every new `OppositeDrawerContainer` instance by the constructor */
    static DISAPPEAR_ANIMATION?: Animation;
}

}

declare module "@typescene/ui/UI/Components/Containers/LayoutContainer" {
import { Container } from "@typescene/ui/UI/Components/Containers/Container";
import { ComponentFactory } from "@typescene/ui/UI/Components/ComponentFactory";
import { Component } from "@typescene/ui/UI/Components/Component";
/** Represents a container with sub containers on up to four sides, and a main area with vertically stacked blocks */
export class LayoutContainer extends Container {
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: LayoutContainer.Initializer) => this;
    /** Default left gutter width, used when left gutter container has no defined width (CSS value, initially 18rem) */
    static LEFT_GUTTER_WIDTH: string;
    /** Default right gutter width, used when right gutter container has no defined width (CSS value, initially 22rem) */
    static RIGHT_GUTTER_WIDTH: string;
    /** Default header height, used when header container has no defined height (CSS value, initially 4rem) */
    static HEADER_HEIGHT: string;
    /** Default footer height, used when footer container has no defined height (CSS value, initially 2rem) */
    static FOOTER_HEIGHT: string;
    /** Header container, if any (observed) */
    header?: Container;
    /** Footer container, if any (observed) */
    footer?: Container;
    /** Left gutter container, if any (observed) */
    leftGutter?: Container;
    /** Right gutter container, if any (observed) */
    rightGutter?: Container;
    /** Set to true to make content within container scrollable; defaults to true for `LayoutContainer` (observed) */
    scrollable?: boolean;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
export namespace LayoutContainer {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Container.Initializer {
        /** Property initializer: header container */
        header?: ComponentFactory.SpecEltOrList | null;
        /** Property initializer: footer container */
        footer?: ComponentFactory.SpecEltOrList | null;
        /** Property initializer: left side container */
        leftGutter?: ComponentFactory.SpecEltOrList | null;
        /** Property initializer: right side container */
        rightGutter?: ComponentFactory.SpecEltOrList | null;
    }
}

}

declare module "@typescene/ui/UI/Components/Controls/BlockControl" {
import { Block } from "@typescene/ui/UI/Components";
import { ControlElement } from "@typescene/ui/UI/Components/Controls/ControlElement";
import { Component } from "@typescene/ui/UI/Components/Component";
import { ComponentFactory } from "@typescene/ui/UI/Components/ComponentFactory";
/** Represents a control element that contains a block */
export class BlockControl<BlockT extends Block> extends ControlElement {
    /** Create a new block control element containing the given block, if any */
    constructor(block?: BlockT);
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: BlockControl.Initializer) => this;
    /** Block element, if any (observed) */
    block?: BlockT;
    /** Overall target width of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component height, may be "auto"); if a width has not been set explicitly, or is set to "auto", then the value is taken from the width of the container */
    width: string;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
export namespace BlockControl {
    /** initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: content block */
        block?: ComponentFactory.SpecEltOrList;
    }
}

}

declare module "@typescene/ui/UI/Components/Controls/Button" {
import { Animation } from "@typescene/ui/UI/Animation";
import { Style } from "@typescene/ui/UI/Style";
import { Container } from "@typescene/ui/UI/Components";
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { ComponentSignalHandler, ComponentSignal, PointerHandler } from "@typescene/ui/UI/Components/ComponentSignal";
import { Menu } from "@typescene/ui/UI/Menu";
import { TextLabelFactory } from "@typescene/ui/UI/Components/TextLabelFactory";
import { ControlElement } from "@typescene/ui/UI/Components/Controls/ControlElement";
/** Represents a button control */
export class Button extends ControlElement {
    /** Create a button control element */
    constructor(label?: string | TextLabelFactory, icon?: string);
    /** Initialize a button control factory with given label and handler */
    static withLabel<T extends Button>(this: {
        new (): T;
        with: typeof Button.with;
    }, label: UIValueOrAsync<string | TextLabelFactory>, clickedHandler?: string | PointerHandler): ComponentFactory<T>;
    /** Initialize a button control factory with given icon and handler */
    static withIcon<T extends Button>(this: {
        new (): T;
        with: typeof Button.with;
    }, icon: UIValueOrAsync<string>, clickedHandler?: string | PointerHandler): ComponentFactory<T>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Button.Initializer) => this;
    /** Button label (observed) */
    label: string;
    /** Optional icon (see `Label#icon`; observed) */
    icon?: string;
    /** Optional icon to be appended after the label text (observed) */
    iconAfter?: string;
    /** Space reserved for icon (rem units), if > 0 (observed) */
    remGutter?: number;
    /** Optional badge text (see `Label#badge`; observed) */
    badge: string;
    /** Tooltip text (observed) */
    tooltipText: string;
    /** Disabled state (observed) */
    disabled: boolean;
    /** Set to true to enable Bootstrap style "primary" class */
    primary: boolean;
    /** Dropdown menu options to be displayed when this button is clicked (optional); defaults to undefined, set to array or ObservableArray to enable */
    dropdown?: Menu.Option[];
    /** Container class or container factory for the contents of a popover to be displayed when this button is clicked (optional) */
    popover?: typeof Container | ComponentFactory<Container>;
    /** Set to true to open popover above this button (vertically) when this button is clicked */
    popoverAbove: boolean;
    /** Title of the popover (optional) displayed when this button is clicked; no title is displayed if this string is undefined or empty */
    popoverTitle: string;
    /** Animation to be used for display of a popover */
    popoverAnimation: Animation;
    /** URL/path string, or (App module) `Activity` instance or `Activity` class that will be activated when this button is clicked (optional) */
    target: any;
    /** Set to false to expand horizontally within row (observed) */
    shrinkwrap: boolean;
    /** Encapsulation of button element style (observed) */
    readonly style_button: Style;
    /** Signal emitted when a dropdown option has been selected */
    readonly DropdownClicked: ComponentSignal.Emittable<string | number, typeof Button.DropdownClickSignal>;
}
export namespace Button {
    /** Signal that is emitted when a dropdown item has been selected */
    class DropdownClickSignal extends ComponentSignal<string | number> {
    }
    /** Contains injectable method for activating targets; instantiated by `Button` */
    class Activation {
        /** Injectable method to activate given target (e.g. URL, or Activity instance or class); default ony handles URLs, `Application` instance injects more functionality here */
        activate(target: any): void;
    }
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: label text */
        label?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: icon (before label) */
        icon?: UIValueOrAsync<string>;
        /** Property initializer: icon (after label) */
        iconAfter?: UIValueOrAsync<string>;
        /** Property initializer: space reserved for icon (rem units) */
        remGutter?: UIValueOrAsync<number>;
        /** Property initializer: badge text */
        badge?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: tooltip text */
        tooltipText?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: true to disable the button */
        disabled?: UIValueOrAsync<boolean>;
        /** Property initializer: true to display as primary button */
        primary?: UIValueOrAsync<boolean>;
        /** Property initializer: dropdown items */
        dropdown?: UIValueOrAsync<Menu.Option[]>;
        /** Property initializer: popover content (container) */
        popover?: UIValueOrAsync<ComponentFactory<Container> | typeof Container>;
        /** Property initializer: true to display popover above button */
        popoverAbove?: UIValueOrAsync<boolean>;
        /** Property initializer: popover title text */
        popoverTitle?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: popover animation (appear) */
        popoverAnimation?: Animation;
        /** Property initializer: target URL, or Activity instance/class */
        target?: any;
        /** Property initializer: button style */
        style_button?: UIValueOrAsync<Style | Style.StyleSet>;
        /** Signal initializer: method name or handler */
        DropdownClicked?: string | ButtonDropdownClickHandler;
    }
}
/** Constructor for a button dropdown click event handler */
export class ButtonDropdownClickHandler extends ComponentSignalHandler<string | number, typeof Button.DropdownClickSignal> {
}
/** Primary button control (shortcut for setting `.primary` on regular `Button` class) */
export class PrimaryButton extends Button {
    primary: boolean;
}
/** Button that switches between selected (active) and deselected (inactive) when clicked (shortcut for setting `toggleMode` on regular `Button` class) */
export class ToggleButton extends Button {
    constructor(label?: string | TextLabelFactory, icon?: string);
}
/** Link-styled button control ("btn-link" class) */
export class LinkButton extends Button {
}
/** Button control that is not decorated as a button */
export class TextButton extends Button {
}
/** Round button control (e.g. with an icon) */
export class RoundButton extends Button {
}

}

declare module "@typescene/ui/UI/Components/Controls/ButtonGroup" {
import { Component } from "@typescene/ui/UI/Components/Component";
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { ComponentRenderer } from "@typescene/ui/UI/Components/ComponentRenderer";
import { Button } from "@typescene/ui/UI/Components/Controls/Button";
import { ControlElement } from "@typescene/ui/UI/Components/Controls/ControlElement";
/** Represents a button group (toggle, tab, or toolbar) control */
export class ButtonGroup extends ControlElement {
    /** Create a button group element */
    constructor(buttons?: Button[]);
    /** Method that is called immediately after the renderer for this button group is constructed; adds observers for button activation */
    protected beforeFirstRender(renderer: ComponentRenderer<this, any>): void;
    /** Initialize a button group control factory with given buttons/button factories; provide selected button index to select (activate) one of the buttons, OR set `multiple` argument to true to allow multiple buttons to be active at once */
    static withButtons<T extends ButtonGroup>(this: {
        new (): T;
        with: typeof ButtonGroup.with;
    }, buttons: Array<Button | ComponentFactory<Button>>, selectedIndex?: number, multiple?: boolean): ComponentFactory<T>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: ButtonGroup.Initializer) => this;
    /** Buttons to be displayed as part of the button group, in order (observed) */
    buttons: Array<Button | undefined>;
    /** Set to true to show buttons from top to bottom (observed) */
    vertical: boolean;
    /** Set to false to expand horizontally within row (observed) */
    shrinkwrap: boolean;
    /** Currently selected button index (base 0) or -1 if no selection (observed) */
    selectedIndex: number;
    private _observableSelectedIndex?;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
export namespace ButtonGroup {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: buttons to display */
        buttons?: ComponentFactory.SpecList;
        /** Property initializer: true to display buttons vertically */
        vertical?: UIValueOrAsync<boolean>;
        /** Property initializer: index of selected button (use with `.selectionMode` set to `ItemClick`) */
        selectedIndex?: UIValueOrAsync<number>;
    }
}

}

declare module "@typescene/ui/UI/Components/Controls/ContainerControl" {
import { Container } from "@typescene/ui/UI/Components";
import { Component } from "@typescene/ui/UI/Components/Component";
import { UIValueOrAsync, ComponentFactory } from "@typescene/ui/UI/Components/ComponentFactory";
import { ControlElement } from "@typescene/ui/UI/Components/Controls/ControlElement";
/** Represents a control element that contains a container */
export class ContainerControl<ContainerT extends Container> extends ControlElement {
    /** Create a container control element that contains the given container, if any */
    constructor(container?: ContainerT);
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: ContainerControl.Initializer) => this;
    /** Container element (created by constructor, but may be modified or set to undefined; defaults to plain Container; observed); if set to a container (other than LayoutContainer) with maxContentWidth other than auto, and this control's width is set to auto, this control will shrinkwrap to the same width as the container */
    container?: ContainerT;
    /** Overall target height of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component height, may be "auto"); if a height has not been set explicitly, or is set to "auto", then the value is taken from the height of the container; for `LayoutContainer`, a value of "100%" is used if the container's height is also "auto" */
    height: string;
    /** Overall target width of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component height, may be "auto"); if a width has not been set explicitly, or is set to "auto", then the value is taken from the width of the container */
    width: string;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
export namespace ContainerControl {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: wrapped container */
        container?: UIValueOrAsync<ComponentFactory<Container> | Container> | ComponentFactory.SpecList2;
    }
}

}

declare module "@typescene/ui/UI/Components/Controls/ControlElement" {
import { Component } from "@typescene/ui/UI/Components/Component";
import { UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
/** UI control element base class */
export abstract class ControlElement extends Component {
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: ControlElement.Initializer) => this;
    /** Width (CSS length), default "auto" (observed) */
    width: string;
    /** Set to true to shrink this element to use as little horizontal space as possible in a row; set to false to expand (observed) */
    shrinkwrap: boolean;
    /** Set to true to automatically break text across lines (observed) */
    wrapText: boolean;
}
export namespace ControlElement {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Component.Initializer {
        /** Property initializer: target width of this component (CSS length) */
        width?: UIValueOrAsync<string>;
        /** Property initializer: true to occupy as little horizontal space as possible */
        shrinkwrap?: UIValueOrAsync<boolean>;
        /** Property initializer: true to focus this component */
        hasFocus?: UIValueOrAsync<boolean>;
    }
}

}

declare module "@typescene/ui/UI/Components/Controls/ControlStack" {
import { Component } from "@typescene/ui/UI/Components/Component";
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { ControlElement } from "@typescene/ui/UI/Components/Controls/ControlElement";
/** Represents a stack control containing control elements with equal widths placed from top to bottom */
export class ControlStack extends ControlElement {
    /** Create a stack element with given content, if any */
    constructor(content?: ControlElement[]);
    /** Initialize a control stack factory with given controls */
    static withContent<T extends ControlStack>(this: {
        new (): T;
        with: typeof ControlStack.with;
    }, content: ComponentFactory.SpecList): ComponentFactory<T>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: ControlStack.Initializer) => this;
    /** Controls to be displayed (observed) */
    content: Array<ControlElement | undefined>;
    /** Spacing between elements (CSS value, observed), defaults to `Row.CONTROL_SPACING` */
    spacing: string;
    /** Horizontal alignment of fixed-width elements within control stack area */
    horzAlign: "left" | "center" | "right";
    /** Set to true to shrink this component horizontally such that it occupies as little space as possible; set to false to expand horizontally within row (observed); note that shrinkwrapping a control stack with non-shrinkwrapped controls may lead to unexpected results; by default, this component observes child components and is only shrinkwrapped if all child components are shrinkwrapped */
    shrinkwrap: boolean;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
export namespace ControlStack {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: list of stacked controls */
        content?: ComponentFactory.SpecList;
        /** Property initializer: margin between controls (CSS value) */
        spacing?: UIValueOrAsync<string>;
        /** Property initializer: horizontal alignment of controls (e.g. "left", "center", "right") */
        horzAlign?: UIValueOrAsync<string>;
    }
}
/** Represents a stack containing control elements with equal width placed from top to bottom, with spacing set to 0 (no margin) */
export class CloseControlStack extends ControlStack {
    spacing: string;
}

}

declare module "@typescene/ui/UI/Components/Controls/Icon" {
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/ui/UI/Components/TextLabelFactory";
import { ControlElement } from "@typescene/ui/UI/Components/Controls/ControlElement";
/** Represents an icon control (horizontally centered) */
export class Icon extends ControlElement {
    /** Create an icon element */
    constructor(icon?: string);
    /** Initialize an icon control with given icon name */
    static withIcon<T extends Icon>(this: {
        new (): T;
        with: typeof Icon.with;
    }, icon: UIValueOrAsync<string>): ComponentFactory<T>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Icon.Initializer) => this;
    /** Icon name as CSS class(es), e.g. "glyphicon-edit" or "fa-edit fa-2x" or "material-icons:file_download"; first part is repeated Bootstrap-style automatically, e.g. "fa-edit" becomes "fa fa-edit"; observed); style properties can be appended like "fa-edit color=#ccc fontSize=200%" (or font-size); use quotes to wrap values with spaces, e.g. 'fa-edit border="1px solid #ccc"' */
    icon: string;
    /** Tooltip text (observed) */
    tooltipText: string;
    /** Set to false to expand horizontally within row (observed) */
    shrinkwrap: boolean;
}
export namespace Icon {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: icon to display */
        icon?: UIValueOrAsync<string>;
        /** Property initializer: tooltip text */
        tooltipText?: UIValueOrAsync<string | TextLabelFactory>;
    }
}

}

declare module "@typescene/ui/UI/Components/Controls/Image" {
import { Style } from "@typescene/ui/UI/Style";
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/ui/UI/Components/TextLabelFactory";
import { ControlElement } from "@typescene/ui/UI/Components/Controls/ControlElement";
/** Represents an image control */
export class Image extends ControlElement {
    /** Create an image element */
    constructor(imageUrl?: string);
    /** Initialize an image control with given URL */
    static withUrl<T extends Image>(this: {
        new (): T;
        with: typeof Image.with;
    }, imageUrl: UIValueOrAsync<string>): ComponentFactory<T>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Image.Initializer) => this;
    /** Image URL (observed) */
    imageUrl: string;
    /** Tooltip text (observed) */
    tooltipText: string;
    /** Set to false to expand horizontally within row (observed) */
    shrinkwrap: boolean;
    /** Encapsulation of image element style (observed) */
    readonly style_img: Style;
    /** True if a load error occurred (observable) */
    hasError: boolean;
    /** Promise that resolves when the image is loaded, or if an error occurred (see .hasError) */
    ready: PromiseLike<void>;
}
export namespace Image {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: image URL */
        imageUrl?: UIValueOrAsync<string>;
        /** Property initializer: image element style */
        style_img?: UIValueOrAsync<Style | Style.StyleSet>;
        /** Property initializer: tooltip text */
        tooltipText?: UIValueOrAsync<string | TextLabelFactory>;
    }
}

}

declare module "@typescene/ui/UI/Components/Controls/InputControls/Checkbox" {
import { Style } from "@typescene/ui/UI/Style";
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/ui/UI/Components/TextLabelFactory";
import { InputControl } from "@typescene/ui/UI/Components/Controls/InputControls/InputControl";
/** Represents a single checkbox or radio button control */
export class Checkbox extends InputControl {
    /** Create a checkbox element */
    constructor(name?: string, label?: string | TextLabelFactory, type?: Checkbox.Type, checked?: boolean);
    /** Initialize a checkbox control factory with given values */
    static withName<T extends Checkbox>(this: {
        new (): T;
        with: typeof Checkbox.with;
    }, name: string, label?: string | TextLabelFactory, checked?: boolean, value?: string): ComponentFactory<T>;
    /** Initialize a radio button control factory with given values */
    static withRadioName<T extends Checkbox>(this: typeof Checkbox & {
        new (): T;
    }, name: string, label?: string | TextLabelFactory, checked?: boolean, value?: string): ComponentFactory<Checkbox>;
    /** Initialize with given (observable) values; returns this */
    initializeWith: (values: Checkbox.Initializer) => this;
    /** Type: checkbox or radio button (observed), defaults to checkbox */
    type: Checkbox.Type;
    /** Text value used when selected (observed), defaults to "checked" */
    value: string;
    /** Current selection status (observable) */
    checked: boolean;
    /** Set to false to expand horizontally within row (observed) */
    shrinkwrap: boolean;
    /** Returns an object containing all current values of input elements (observable) */
    getFormValues(result?: {}): {};
    /** Sets all input values by element name */
    setFormValues(values: any): void;
    /** Encapsulation of inner text element style (observed) */
    readonly style_text: Style;
}
export namespace Checkbox {
    enum Type {
        Checkbox = 0,
        Radio = 1,
    }
    /** Initializer for .with({ ... }) */
    interface Initializer extends InputControl.Initializer {
        /** Property initializer: true to check checkbox/radio */
        checked?: UIValueOrAsync<boolean | undefined>;
        /** Property initializer: checkbox or radio */
        type?: UIValueOrAsync<Checkbox.Type>;
        /** Property initializer: text element style */
        style_text?: UIValueOrAsync<Style | Style.StyleSet>;
    }
}

}

declare module "@typescene/ui/UI/Components/Controls/InputControls/InputControl" {
import { Style } from "@typescene/ui/UI/Style";
import { ActionHandler, ComponentSignal } from "@typescene/ui/UI/Components/ComponentSignal";
import { UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/ui/UI/Components/TextLabelFactory";
import { ControlElement } from "@typescene/ui/UI/Components/Controls/ControlElement";
/** Input field control base class (abstract) */
export abstract class InputControl extends ControlElement {
    /** Input value (read/write) */
    value: string;
    /** Form input property name, if any (observed) */
    name: string;
    /** Label text (observed) */
    label: string;
    /** Tooltip text (observed) */
    tooltipText: string;
    /** True if input is disabled and read-only (observed) */
    disabled: boolean;
    /** Encapsulation of label element style (observed) */
    readonly style_label: Style;
    /** Encapsulation of input element style (observed) */
    readonly style_input: Style;
    /** Signal emitted when the input value is committed (on change); captured from containers down to contained components, not consumed */
    readonly ValueChange: ComponentSignal.Emittable<any, typeof ComponentSignal>;
    /** Signal emitted immediately before the input value changes (on input); captured from containers down to contained components, not consumed */
    readonly ValueInput: ComponentSignal.Emittable<any, typeof ComponentSignal>;
}
export namespace InputControl {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: form input property name */
        name?: string;
        /** Property initializer: input value */
        value?: UIValueOrAsync<string>;
        /** Property initializer: label text */
        label?: UIValueOrAsync<string | undefined> | TextLabelFactory;
        /** Property initializer: tooltip text */
        tooltipText?: UIValueOrAsync<string | undefined> | TextLabelFactory;
        /** Property initializer: true to disable this input */
        disabled?: UIValueOrAsync<boolean>;
        /** Property initializer: label style */
        style_label?: UIValueOrAsync<Style | Style.StyleSet>;
        /** Property initializer: input style */
        style_input?: UIValueOrAsync<Style | Style.StyleSet>;
        /** Signal initializer: method name or handler */
        ValueChange?: string | ActionHandler;
        /** Signal initializer: method name or handler */
        ValueInput?: string | ActionHandler;
    }
}

}

declare module "@typescene/ui/UI/Components/Controls/InputControls/SelectField" {
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/ui/UI/Components/TextLabelFactory";
import { InputControl } from "@typescene/ui/UI/Components/Controls/InputControls/InputControl";
/** Represents a native dropdown selection field control */
export class SelectField extends InputControl {
    /** Create a select field element */
    constructor(name?: string, label?: string | TextLabelFactory, options?: SelectField.Option[]);
    /** Initialize a select field control factory with given name, label, and options */
    static withOptions<T extends SelectField>(this: {
        new (): T;
        with: typeof SelectField.with;
    }, name: string, label?: string | TextLabelFactory, options?: UIValueOrAsync<SelectField.Option[]>): ComponentFactory<T>;
    /** Initialize with given (observable) values; returns this */
    initializeWith: (values: SelectField.Initializer) => this;
    /** List of options and their values (observed) */
    options: Array<SelectField.Option | undefined>;
    /** Currently selected value (read/write observable) */
    value: string;
    /** Returns an object containing all current values of input elements (observable) */
    getFormValues(result?: {}): {};
    /** Sets all input values by element name */
    setFormValues(values: any): void;
}
export namespace SelectField {
    /** Represents a select field option */
    interface Option {
        /** Selection value */
        value?: string;
        /** Text label */
        text: string | TextLabelFactory;
    }
    /** Initializer for .with({ ... }) */
    interface Initializer extends InputControl.Initializer {
        /** Property initializer: options with text labels and (optional) values */
        options?: UIValueOrAsync<SelectField.Option[]>;
    }
}

}

declare module "@typescene/ui/UI/Components/Controls/InputControls/TextField" {
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/ui/UI/Components/TextLabelFactory";
import { InputControl } from "@typescene/ui/UI/Components/Controls/InputControls/InputControl";
/** Represents a single- or multi-line text input field control */
export class TextField extends InputControl {
    /** Create a text field */
    constructor(name?: string, label?: string | TextLabelFactory, textareaLines?: number);
    /** Initialize a text field control factory with given name, label, and placeholder */
    static withName<T extends TextField>(this: {
        new (): T;
        with: typeof TextField.with;
    }, name: string, label?: string | TextLabelFactory, placeholderText?: string | TextLabelFactory): ComponentFactory<T>;
    /** Initialize with given (observable) values; returns this */
    initializeWith: (values: TextField.Initializer) => this;
    /** Number of rows for a multiline text field, default 0 (NOT observed) */
    textareaLines: number;
    /** Text field type (text, password, number, etc.; observed) */
    type: TextField.Type;
    /** Current input value (read/write observable) value changes only on blur or enter press unless `.immediateValueUpdate` is set */
    value: string;
    /** Placeholder text (observed) */
    placeholderText: string;
    /** Set to true to update `.value` immediately after the input field text has changed, instead of only on blur or enter press (observed) */
    immediateValueUpdate: boolean;
    /** Select (a part of) the text in this text field, returns this */
    selectText(start?: number, end?: number): this;
    /** Returns an object containing all current values of input elements (observable) */
    getFormValues(result?: {}): {};
    /** Sets all input values by element name */
    setFormValues(values: any): void;
}
export namespace TextField {
    /** Text field type options (e.g. Text, Password, Email etc.) */
    enum Type {
        Text = 0,
        Password = 1,
        DateTime = 2,
        Date = 3,
        Month = 4,
        Time = 5,
        Week = 6,
        Number = 7,
        Email = 8,
        Url = 9,
        Search = 10,
        Tel = 11,
        Color = 12,
    }
    /** Initializer for .with({ ... }) */
    interface Initializer extends InputControl.Initializer {
        /** Property initializer: number of text area lines */
        textareaLines?: UIValueOrAsync<number>;
        /** Property initializer: text field type */
        type?: UIValueOrAsync<TextField.Type>;
        /** Property initializer: placeholder text */
        placeholderText?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: true to update value immediately on input */
        immediateValueUpdate?: UIValueOrAsync<boolean>;
    }
}

}

declare module "@typescene/ui/UI/Components/Controls/Label" {
import { Style } from "@typescene/ui/UI/Style";
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/ui/UI/Components/TextLabelFactory";
import { ControlElement } from "@typescene/ui/UI/Components/Controls/ControlElement";
/** Represents a minimal text control with icon and badge */
export class Label extends ControlElement {
    /** Create a label element */
    constructor(text?: string | TextLabelFactory, icon?: string, remGutter?: number, badge?: string | TextLabelFactory);
    /** Initialize a text control factory with given text and style */
    static withText<T extends Label>(this: {
        new (): T;
        with: typeof Label.with;
    }, text: UIValueOrAsync<string | TextLabelFactory>, style?: UIValueOrAsync<Style | Style.StyleSet>): ComponentFactory<T>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Label.Initializer) => this;
    /** Set to false to expand horizontally within row (default true; observed) */
    shrinkwrap: boolean;
    /** Text to display (observed) */
    text: string;
    /** Icon to be placed in front of the label text (CSS class(es), e.g. "glyphicon-edit" or "fa-edit fa-2x" or "material-icons:file_download"; first part is repeated Bootstrap-style automatically, e.g. "fa-edit" becomes "fa fa-edit"; observed); style properties can be appended like "fa-edit color=#ccc fontSize=200%" (or font-size); use quotes to wrap values with spaces, e.g. 'fa-edit border="1px solid #ccc"' */
    icon?: string;
    /** Space reserved for icon (rem units), if > 0 (observed) */
    remGutter: number;
    /** Badge text, if any (observed) */
    badge: string;
    /** Tooltip text (observed) */
    tooltipText: string;
}
export namespace Label {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: text to display */
        text?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: icon to display */
        icon?: UIValueOrAsync<string>;
        /** Property initializer: space reserved for icon, in rem units */
        remGutter?: UIValueOrAsync<number>;
        /** Property initializer: badge text to display */
        badge?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: tooltip text */
        tooltipText?: UIValueOrAsync<string | TextLabelFactory>;
    }
}
/** Stretched label control: a label that expands horizontally, while not breaking across lines (uses ellipsis if available) */
export class WideLabel extends Label {
    /** Set to true to shrink horizontally (default false; observed) */
    shrinkwrap: boolean;
}
/** Paragraph control: a label that expands horizontally, with text that breaks automatically across lines, and added line spacing for enhanced readability */
export class Paragraph extends Label {
    /** Set to true to shrink horizontally (default false; observed) */
    shrinkwrap: boolean;
    /** Automatically break text across lines (default true, observed) */
    wrapText: boolean;
}
/** H1 label control */
export class Heading1 extends Label {
}
/** H2 label control */
export class Heading2 extends Label {
}
/** H3 label control */
export class Heading3 extends Label {
}
/** H4 label control */
export class Heading4 extends Label {
}
/** H5 label control */
export class Heading5 extends Label {
}
/** H6 label control */
export class Heading6 extends Label {
}

}

declare module "@typescene/ui/UI/Components/Controls/ProgressBar" {
import { Style } from "@typescene/ui/UI/Style";
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/ui/UI/Components/TextLabelFactory";
import { ControlElement } from "@typescene/ui/UI/Components/Controls/ControlElement";
/** Represents a progress bar control (full width by default) */
export class ProgressBar extends ControlElement {
    /** Create a progress bar control element */
    constructor(progress?: number);
    /** Initialize a progress bar control factory with given progress value (0-1) */
    static withProgress<T extends ProgressBar>(this: {
        new (): T;
        with: typeof ProgressBar.with;
    }, progress: UIValueOrAsync<number>): ComponentFactory<T>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: ProgressBar.Initializer) => this;
    /** Current progress value, between 0 and 1, inclusive (observed) */
    progress: number;
    /** Tooltip text (observed) */
    tooltipText: string;
    /** Encapsulation of inner bar style (observed) */
    readonly style_bar: Style;
}
export namespace ProgressBar {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: progress value (0-1) */
        progress?: UIValueOrAsync<number>;
        /** Property initializer: tooltip text */
        tooltipText?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: inner bar element style */
        style_bar?: UIValueOrAsync<Style | Style.StyleSet>;
    }
}

}

declare module "@typescene/ui/UI/Components/Controls/Spacer" {
import { ComponentFactory, UIValueOrAsync } from "@typescene/ui/UI/Components/ComponentFactory";
import { ControlElement } from "@typescene/ui/UI/Components/Controls/ControlElement";
/** Represents an empty control element to take up horizontal space within a row */
export class Spacer extends ControlElement {
    /** Create a spacer element with given height (default 1px) */
    constructor(height?: string);
    /** Initialize a spacer control factory with given size (CSS lengths) */
    static withSize<T extends Spacer>(this: {
        new (): T;
        with: typeof Spacer.with;
    }, width?: UIValueOrAsync<string>, height?: UIValueOrAsync<string>): ComponentFactory<T>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Spacer.Initializer) => this;
}
export namespace Spacer {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
    }
}

}

declare module "@typescene/ui/UI/Components" {
export * from "@typescene/ui/UI/Components/Component";
export * from "@typescene/ui/UI/Components/ComponentSignal";
export * from "@typescene/ui/UI/Components/ComponentFactory";
export * from "@typescene/ui/UI/Components/ComponentRenderer";
export * from "@typescene/ui/UI/Components/TextLabelFactory";
export * from "@typescene/ui/UI/Components/Containers/Container";
export * from "@typescene/ui/UI/Components/Containers/DialogContainer";
export * from "@typescene/ui/UI/Components/Containers/DrawerContainer";
export * from "@typescene/ui/UI/Components/Containers/LayoutContainer";
export * from "@typescene/ui/UI/Components/Blocks/Block";
export * from "@typescene/ui/UI/Components/Blocks/Card";
export * from "@typescene/ui/UI/Components/Blocks/ContainerBlock";
export * from "@typescene/ui/UI/Components/Blocks/Divider";
export * from "@typescene/ui/UI/Components/Blocks/List";
export * from "@typescene/ui/UI/Components/Blocks/TreeList";
export * from "@typescene/ui/UI/Components/Blocks/NavList";
export * from "@typescene/ui/UI/Components/Blocks/Row";
export * from "@typescene/ui/UI/Components/Blocks/Table";
export * from "@typescene/ui/UI/Components/Blocks/TableRow";
export * from "@typescene/ui/UI/Components/Controls/ControlElement";
export * from "@typescene/ui/UI/Components/Controls/BlockControl";
export * from "@typescene/ui/UI/Components/Controls/Button";
export * from "@typescene/ui/UI/Components/Controls/ButtonGroup";
export * from "@typescene/ui/UI/Components/Controls/ContainerControl";
export * from "@typescene/ui/UI/Components/Controls/ControlStack";
export * from "@typescene/ui/UI/Components/Controls/Icon";
export * from "@typescene/ui/UI/Components/Controls/Image";
export * from "@typescene/ui/UI/Components/Controls/Label";
export * from "@typescene/ui/UI/Components/Controls/ProgressBar";
export * from "@typescene/ui/UI/Components/Controls/Spacer";
export * from "@typescene/ui/UI/Components/Controls/InputControls/InputControl";
export * from "@typescene/ui/UI/Components/Controls/InputControls/Checkbox";
export * from "@typescene/ui/UI/Components/Controls/InputControls/SelectField";
export * from "@typescene/ui/UI/Components/Controls/InputControls/TextField";
export * from "@typescene/ui/UI/Components/Composite/MessageDialog";
export * from "@typescene/ui/UI/Components/Composite/ConfirmationDialog";
export * from "@typescene/ui/UI/Components/Composite/Toast";
export * from "@typescene/ui/UI/Components/Composite/TreeListRow";

}

declare module "@typescene/ui/UI/Components/TextLabelFactory" {
import * as Async from "@typescene/async";
import { Binding } from "@typescene/ui/UI/Binding";
import { Label } from "@typescene/ui/UI";
import { Component } from "@typescene/ui/UI/Components/Component";
/** Shared factory implementation for a piece of text as a string and/or as (an observable value representing) a Label instance (or sub class); can be used in Component factory specs using UI.tl(...) or with backticks */
export class TextLabelFactory {
    /** Create the text label factory using the given string, stringable (object with .toString method), observable value, or a function that returns an observable value, and a Label base class that is used if not overridden by string content prefix */
    constructor(text: {
        toString;
    } | Async.ObservableValue<{
        toString;
    }> | TextLabelFactory.TLInitializer, baseClass?: typeof Label);
    /** Get the encapsulated text as a string; adds a dependency on the observable value if called from an obserable value getter; trims {...} prefix if present */
    toString(): string;
    /** Get the encapsulated text wrapped in a new Label (or derived) instance, or an observable value representing the instance; uses {...} prefix to control component type and its properties; parameters are used by compononent factory to initialize bindings used in `tl` strings, if any */
    getComponent(baseComponent?: Component, propertyName?: string): Label | Async.ObservableValue<Label>;
    private _createComponent(text, prev?);
    private _baseClass;
    private _value;
}
export namespace TextLabelFactory {
    /** Function used by `tl` to construct TextLabelFactory that can only construct a `Label` instance if a base component and property name is given, to convert bindings into observables */
    type TLInitializer = (baseComponent: Component, propertyName: string) => Async.ObservableValue<string>;
}
/** Tagged template string function that returns a text label factory instance to be used with component factory content lists; functions in the expanded values (i.e. result of ${...}), and bindings (instanceof Binding), are used as getters for nested observable string values (e.g. ${() => ...} is observed and converted to a string); prefixes can be used to change the type of component factory created and its styles and properties:
 * * `{p}` for Paragraph,
 * * `{h1-6}` for Heading,
 * * `{w}` for WideLabel,
 * * `{b|i|u}` for text styles,
 * * `{left|center|right}` for alignment,
 * * `{#...}` for text colors,
 * * `{nnn}` for font weights,
 * * `{icon:...}` for icons,
 * * `{icon:... property-name=...}` for icon style properties,
 * * `{property-name=...}` or `{propertyName=...}` for individual style properties,
 * * `{.classname}` and `{.class1.class2}` for class name(s),
 * * `{...%|...em|...rem| etc.}` for font sizes, and
 * * `{l:...%|...rem| etc.}` for Label with given width;
 *
 * Prefixes can be combined using the pipe | symbol and may also be the result of an expanded value (i.e. first ${...} part)
 */
export function tl(strings: TemplateStringsArray, ...values: any[]): TextLabelFactory;
/** Simplified version of tagged template helper .tl\`...\` with a single piece of text, possibly with a base Label class that is used if given string does not override the class using e.g. `{p}` or `{h1}` */
export function tl(text: string | Async.ObservableValue<string>, baseClass?: typeof Label): TextLabelFactory;
/** Simplified version of tagged template helper .tl\`...\` observing a single piece of text, possibly with a base Label class that is used if given string does not override the class using e.g. `{p}` or `{h1}` */
export function tl(getter: () => (string | Async.ObservableValue<string>), baseClass?: typeof Label): TextLabelFactory;
/** Simplified version of tagged template helper .tl\`...\` observing a single binding, possibly with a base Label class that is used if given string does not override the class using e.g. `{p}` or `{h1}` */
export function tl(getter: Binding<string>, baseClass?: typeof Label): TextLabelFactory;

}

declare module "@typescene/ui/UI/DOM/DOM" {
import * as Async from "@typescene/async";
import { Component } from "@typescene/ui/UI/Components/Component";
import { Style } from "@typescene/ui/UI/Style";
/** Static container for helper methods that work with the DOM */
export namespace DOM {
    /** Returns true if given component contains given DOM node */
    function contains(component: Component, node: Node): boolean;
    /** Try to focus given component, its live element (from rendered output), or the first focusable element within given component, as soon as it becomes available */
    function focus(component: Component): void;
    /** Remove focus from given component, or the currently focused element */
    function blur(component?: Component): void;
    /** Unique random identifier for this runtime instance of the library, used as an identifier on page root elements */
    const uid: string;
    /** Represents a (live updating) style sheet, with an optional base class name; the style sheet consists of one or more CSS selectors that each contain a reference to a `Style` instance */
    class Stylesheet {
        /** Create a new style sheet, with given base class name(s) (optional) and given selectors and styles; selectors may be written as `"@... { selector }"` for e.g. @keyframe and @media nested at-rules; also, `.~~` will be replaced with the full base class name and `.~` with the final part, or if not included then the base class name will be prepended */
        constructor(baseClassName?: string, sheet?: {
            [selector: string]: Style.StyleSet | Style | undefined;
        });
        /** Base class name for this style sheet (set using constructor call) */
        readonly baseClassName: string;
        /** Returns a list of selectors defined in this style sheet (observable) */
        listSelectors(): string[];
        /** Append a rule to this style sheet; returns this */
        define(text: string): any;
        /** Define or override styles for given selector, based on the properties stored in given `Style` instance (class names are ignored); selectors may be written as `"@... { selector }"` for e.g. @keyframe and @media nested at-rules; returns this */
        define(selector: string, style: Style.StyleSet | Style): any;
        /** Remove defined styles for given selector or pattern; returns this */
        remove(selector: string | RegExp): this;
        /** Invoke given function for each selector of this style sheet, including instance identifier class and base class (except for keyframe selectors), if any, and the referenced `Style` instance, if any; to be used in an observable context to watch for changes*/
        forEach(callback: (selector: string, style?: Style) => void): void;
        private _selectors;
        private _keys;
    }
    /** Define global CSS styles from given list of selectors and style properties, in the context of the current runtime instance */
    function applyStylesheet(styles: {
        [selector: string]: Style.StyleSet | Style;
    }): any;
    /** Define global CSS styles from given style sheet, in the context of the current runtime instance; if the `liveUpdate` argument is set to true, changes to the style sheet are observed and reflected in the DOM asynchronously */
    function applyStylesheet(sheet: Stylesheet, liveUpdate?: boolean): any;
    /** Helper function to apply Style properties to given DOM element; returns the Style object (does not observe styles directly, but can be used in an observable getter, e.g. using `ComponentRenderer#watch` to reapply styles when they change) */
    function applyStyleTo(style: Style, element: HTMLElement): void;
    /** Set the global root-em unit size in pixels or using a CSS value string */
    function setCSSRemSize(px: number | string): void;
    /** Set the class name globally applied to selected items (in addition to the `selected` DOM attribute) */
    function setSelectionClass(className: string): void;
    /** Get the class name globally applied to selected items (if any) */
    function getSelectionClass(): string;
    /** Load external stylesheet(s) by URL; returns a promise that resolves after the style sheet(s) have been applied (or after a 1s timeout for browsers that do not support onload event for link elements) */
    function loadExternalCSS(...urls: string[]): PromiseLike<any>;
    /** A set of predefined styles and style sheets that are used by specific components; these may be modified to apply a "theme", which will generally update all styles in the DOM asynchronously; _however_, styles defined here are subject to change for now and it is not guaranteed that selectors and class names will continue to exist across versions */
    namespace CSS {
        /** Groups basic component style sheet definitions together, indexed by class name (e.g. "UI-Container") */
        const components: {
            readonly [className: string]: Stylesheet;
        };
        /** Contains observable definitions of basic CSS values that can used in styles and style sheets; initially only contains "baseFontSize" (defaults to `1rem`) and "Paragraph.lineHeight" but more properties can be added here, provided they are properly namespaced */
        const variables: {
            [name: string]: Async.ObservableValue<string>;
        };
    }
    /** Collection of options that control page rendering */
    interface DOMPageOptions {
        /** The z-index style property of the page and all content (default 1000) */
        baseZIndex: number;
        /** Timing (ms) for the modal "shade" in/out animation (default 200) */
        shadeTransition: number;
        /** Opacity level (0-1) for the modal "shade" backdrop (default 0.2) */
        shadeOpacity: number;
        /** CSS base color for the modal "shade" backdrop (default "#000") */
        shadeColor: string;
    }
    /** Options that control page rendering */
    const PAGE_OPTIONS: DOMPageOptions;
}

}

declare module "@typescene/ui/UI/DOM/DOMAnimation" {
import { Animation } from "@typescene/ui/UI/Animation";
import { Style } from "@typescene/ui/UI/Style";
import { Component } from "@typescene/ui/UI/Components/Component";
/** Represents a CSS keyframe animation */
export class DOMAnimation extends Animation {
    /** Create a combined animation out of given key frame animations */
    static together(...animations: DOMAnimation[]): Animation;
    /** Get an animation with given keyframes and given playback options ready for use */
    constructor(name: string, keyframes?: DOMAnimation.Keyframe[], options?: DOMAnimation.Options);
    /** Clone the animation with the same keyframes but with extra options */
    clone(options: DOMAnimation.Options): DOMAnimation;
    /** Combine this animation with given key frame animations; this does *not* work for animations that use the same CSS property, such as `transform` (rotate, scale, translate...) */
    togetherWith(...animations: DOMAnimation[]): Animation;
    /** Clone this animation and override timings */
    withTiming(msDuration: number, msDelay?: number): DOMAnimation;
    /** Clone this animation and specify to be played in reverse */
    reverse(): DOMAnimation;
    /** Play the animation once on given component */
    play(component: Component): Animation.AnimationControl<DOMAnimation>;
}
export namespace DOMAnimation {
    /** Represents a single keyframe in an animation */
    interface Keyframe {
        /** Keyframe position (fraction, 0-1), defaults to the relative position of this keyframe from 0 to 1 (i.e. first keyframe to 0, second in a set of three keyframes to 0.5, second in a set of four keyframes to 0.25, etc) */
        t?: number;
        /** Keyframe style properties */
        style: Style.StyleSet | Style;
    }
    /** Keyframe animation options */
    interface Options {
        /** Duration in milliseconds (default 500) */
        duration?: number;
        /** Duration specified in CSS (copied from duration if unspecified) */
        specDuration?: number;
        /** Delay in milliseconds before starting the animation (default 0) */
        delay?: number;
        /** Number of iterations to play (default 1; can be Infinity) */
        count?: number;
        /** Direction to play the keyframes in (normal, reverse, alternate, or alternate-reverse; default normal) */
        direction?: "normal" | "reverse" | "alternate" | "alternate-reverse";
        /** Set to true to ease the animation timing */
        ease?: boolean;
    }
    /** List of basic animations [implementation] */
    var basic: {
        in: {
            fade: DOMAnimation;
            fadeUp: DOMAnimation;
            fadeDown: DOMAnimation;
            fadeLeft: DOMAnimation;
            fadeRight: DOMAnimation;
            slideUp: DOMAnimation;
            slideDown: DOMAnimation;
            slideLeft: DOMAnimation;
            slideRight: DOMAnimation;
            scale: DOMAnimation;
            scaleOver: DOMAnimation;
            turnX: DOMAnimation;
            turnY: DOMAnimation;
            maxHeight: DOMAnimation;
            maxWidth: DOMAnimation;
        };
        out: {
            fade: DOMAnimation;
            fadeUp: DOMAnimation;
            fadeDown: DOMAnimation;
            fadeLeft: DOMAnimation;
            fadeRight: DOMAnimation;
            slideUp: DOMAnimation;
            slideDown: DOMAnimation;
            slideLeft: DOMAnimation;
            slideRight: DOMAnimation;
            scale: DOMAnimation;
            scaleOver: DOMAnimation;
            turnX: DOMAnimation;
            turnY: DOMAnimation;
            maxHeight: DOMAnimation;
            maxWidth: DOMAnimation;
        };
        highlight: {
            yellow: DOMAnimation;
            jumpOut: DOMAnimation;
            jumpIn: DOMAnimation;
        };
    };
}

}

declare module "@typescene/ui/UI/DOM/DOMBlock" {
import * as Async from "@typescene/async";
import { Block } from "@typescene/ui/UI/Components/Blocks/Block";
/** Block base class: full-width horizontal block containing DOM element(s) */
export class DOMBlock extends Block {
    /** Create a new block component with given content */
    constructor(...elements: Array<Node | Async.ObservableValue<Node>>);
    /** Create a new block component with elements from the given DOM fragment */
    constructor(documentFragment: DocumentFragment);
    /** Array of DOM nodes (observed) */
    nodes: Array<Node | undefined>;
}

}

declare module "@typescene/ui/UI/DOM/DOMDrag" {

}

declare module "@typescene/ui/UI/DOM/DOMEvents" {

}

declare module "@typescene/ui/UI/DOM/DOMPageRenderer" {

}

declare module "@typescene/ui/UI/DOM/DOMUpdater" {

}

declare module "@typescene/ui/UI/DOM" {
export { DOM } from "@typescene/ui/UI/DOM/DOM";
import "./DOMDrag";
import "./DOMEvents";
import "./DOMPageRenderer";
import "./DOMUpdater";
import "./Renderers";
import "./Toast";
import "./PopOver";
import "./Menu";
export { DOMAnimation } from "@typescene/ui/UI/DOM/DOMAnimation";
export { DOMBlock } from "@typescene/ui/UI/DOM/DOMBlock";

}

declare module "@typescene/ui/UI/DOM/Menu" {

}

declare module "@typescene/ui/UI/DOM/PopOver" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Blocks/Block" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Blocks/Card" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Blocks/ContainerBlock" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Blocks/Divider" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Blocks/List" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Blocks/NavList" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Blocks/Row" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Blocks/Table" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Blocks/TableRow" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Containers/Container" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Containers/DialogContainer" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Containers/DrawerContainer" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Containers/LayoutContainer" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Controls/BlockControl" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Controls/Button" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Controls/ButtonGroup" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Controls/ContainerControl" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Controls/ControlElement" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Controls/ControlStack" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Controls/Icon" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Controls/Image" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Controls/InputControls/Checkbox" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Controls/InputControls/SelectField" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Controls/InputControls/TextField" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Controls/Label" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Controls/ProgressBar" {

}

declare module "@typescene/ui/UI/DOM/Renderers/Controls/Spacer" {

}

declare module "@typescene/ui/UI/DOM/Renderers" {
import "./Containers/Container";
import "./Containers/DialogContainer";
import "./Containers/DrawerContainer";
import "./Containers/LayoutContainer";
import "./Blocks/Block";
import "./Blocks/Card";
import "./Blocks/ContainerBlock";
import "./Blocks/Divider";
import "./Blocks/List";
import "./Blocks/NavList";
import "./Blocks/Row";
import "./Blocks/Table";
import "./Blocks/TableRow";
import "./Controls/BlockControl";
import "./Controls/Button";
import "./Controls/ButtonGroup";
import "./Controls/ContainerControl";
import "./Controls/ControlElement";
import "./Controls/ControlStack";
import "./Controls/Icon";
import "./Controls/Image";
import "./Controls/Label";
import "./Controls/ProgressBar";
import "./Controls/Spacer";
import "./Controls/InputControls/Checkbox";
import "./Controls/InputControls/SelectField";
import "./Controls/InputControls/TextField";

}

declare module "@typescene/ui/UI/DOM/Toast" {

}

declare module "@typescene/ui/UI/Drag" {
import * as Async from "@typescene/async";
import { Component, PointerEvent } from "@typescene/ui/UI";
/** Represents a signal that is emitted when a drag operation is completed (drop or cancel) */
export class DragEndSignal extends Async.Signal<Drag> {
}
/** Represents a drag operation (created by static .start(...) method) */
export abstract class Drag {
    /** Returns a list of current drag operations (for forwards compatibility, supporting multi touch); use this while handling drag events, e.g. get/set .detail with custom data, or observe coordinates) */
    static getCurrentInstances(): Drag[];
    /** Start tracking mouse movement based on given event (with initial screen coordinates); creates a new instance of a platform specific class derived from Drag with given payload data; Drop targets may listen for drag events (enter/leave/drop), and use information from the data object to respond */
    static start(event: PointerEvent, data?: any): Drag;
    /** Event payload data for this operation (sealed observable object) */
    readonly detail: Drag.DragEventDetail;
    /** Current screen X coordinate (read-only observable, constrained) */
    readonly abstract x: number;
    /** Current screen Y coordinate (read-only observable, constrained) */
    readonly abstract y: number;
    /** Resolves to `this` when the observed coordinates actually change by a reasonable amount (to distinguish from a click), useful e.g. for calling `.pickUp(...)` only when resolved */
    readonly abstract moved: PromiseLike<Drag>;
    /** Signal emitted when the drag operation completes successfully */
    readonly Dropped: Async.Signal.Emittable<Drag, typeof DragEndSignal>;
    /** Signal emitted when the drag operation is canceled */
    readonly Canceled: Async.Signal.Emittable<Drag, typeof DragEndSignal>;
    /** Constrain effective drag coordinates on (original) X and/or Y axis, and/or contrain to stay within given component on screen (calling this method twice does not constrain further, but the constraints are replaced) */
    abstract constrain(constrainX?: boolean, constrainY?: boolean, component?: Component): void;
    /** Make given component follow the mouse cursor while dragging */
    abstract pickUp(component: Component, removeWhenDone?: boolean): void;
    /** Stop this drag operation, emits the `.Canceled` signal; throws an exception if this operation was already canceled or dropped */
    cancel(): void;
    /** Accept the current drop target (i.e. perform the drop, called automatically based on input events, but can be called manually as well), emits the `.Dropped` signal; throws an exception if this operation was already canceled or dropped */
    drop(): void;
}
export namespace Drag {
    /** Details that are emitted along with a drag event */
    interface DragEventDetail {
        /** Platform-specific drag event identifier (may be undefined) */
        id: undefined;
        /** Application defined payload to identify the object being dragged */
        data: undefined;
    }
}

}

declare module "@typescene/ui/UI" {
export * from "@typescene/ui/UI/Components";
export * from "@typescene/ui/UI/Style";
export * from "@typescene/ui/UI/Page";
export * from "@typescene/ui/UI/Screen";
export * from "@typescene/ui/UI/Binding";
export * from "@typescene/ui/UI/Animation";
export * from "@typescene/ui/UI/Drag";
export * from "@typescene/ui/UI/Menu";
export * from "@typescene/ui/UI/PopOver";
export * from "@typescene/ui/UI/DOM";

}

declare module "@typescene/ui/UI/Menu" {
import { Component, PointerEvent, TextLabelFactory } from "@typescene/ui/UI";
/** Contains methods for displaying dropdown menus and context menus */
export namespace Menu {
    /** Display a modal context menu; returns a Promise that resolves to the index(base 1)/key of the selected menu item, or is rejected if the user cancels the context menu */
    function displayContextMenu(options: Menu.Option[], event: PointerEvent): PromiseLike<string | number>;
    /** Display a modal dropdown menu below the given component (or above, depending on available screen space); returns a Promise that resolves to the index(base 1)/key of the selected menu item, or is rejected if the user cancels the context menu */
    function displayDropdown(options: Menu.Option[], component: Component): PromiseLike<string | number>;
    /** Dismiss the menu currently on screen, if any */
    function dismiss(): void;
    /** Represents a context/dropdown menu option or divider */
    interface Option {
        /** Optional key (string) used as an identifier */
        key?: string;
        /** Menu item label text */
        label?: string | TextLabelFactory;
        /** Menu item icon */
        icon?: string;
        /** Menu item icon displayed on the far side, next to where a sub menu would open */
        sideIcon?: string;
        /** Set to true to disable this menu item */
        disabled?: boolean;
        /** Set to true (and leave other properties out) to display a divider instead of a menu option in this position */
        divider?: boolean;
        /** Sub menu options, displayed when this item is selected/focused */
        subMenu?: Option[];
    }
}

}

declare module "@typescene/ui/UI/Page" {
import * as Async from "@typescene/async";
import { Component, KeyboardEvent } from "@typescene/ui/UI";
/** Represents a page to be displayed on screen */
export class Page {
    /** Returns the page currently displayed on screen, if any (observable) */
    static getCurrentPage(): Page | undefined;
    /** Globally unique page identifier */
    readonly uid: string;
    /** Components that are displayed on this page, each component stacked on top of the previous one along the z-axis (observed) */
    content: Array<Component | undefined>;
    /** Returns the nearest matching child element with given ID, if any (observable) */
    getComponentById(id: string): Component | undefined;
    /** Returns the nearest matching child element with given ID _and_ that is an instance of given class, if any (observable) */
    getComponentById<C extends Component>(id: string, componentClass: typeof Component & {
        new (...p: any[]): C;
    }): C | undefined;
    /** Returns all (recursive) child elements that are an instance of given class (observable) */
    getComponentsByType<C extends Component>(componentClass: typeof Component & {
        new (...p: any[]): C;
    }): C[];
    /** Invoke the `onEsc` handler of the component closest to the foreground that defines it (usually a modal dialog container in the foreground); returns true if handler was called, otherwise does nothing and returns false */
    handleEsc(): boolean;
    /** Scroll the page and all parent components of given component, such that the entire component becomes visible */
    scrollTo(component: Component): void;
    /** Display this page on screen; also re-enables the page if input was blocked; replaces the currently displaying page on screen, which is removed automatically, but the result may be an empty screen if this page has no content; always waits for `Screen.ready`; returns this */
    display(): this;
    /** Remove this page from the screen, if currently displayed; returns this */
    remove(): this;
    /** Block all input events on this page, until given promise is resolved, or until page is re-displayed */
    disable(promise?: PromiseLike<any>): void;
    /** Signal that is emitted after this page is displayed on screen */
    readonly Displayed: Async.Signal.Emittable<any, typeof PageSignal>;
    /** Signal that is emitted after this page has been removed from the screen */
    readonly Removed: Async.Signal.Emittable<any, typeof PageSignal>;
    /** Signal that is emitted after the content of this page has been (re-) rendered, e.g. when a component is added or removed (but not when one of the components itself is re-rendered due to changes in its own sub content, use the `Component#Rendered` signal for that) */
    readonly Rendered: Async.Signal.Emittable<any, typeof PageSignal>;
    /** Signal that is emitted when a key is being pressed on the keyboard, while this page is displayed in the foreground */
    readonly KeyDown: Async.Signal.Emittable<KeyboardEvent, typeof PageSignal>;
    /** @Internal disabled state */
    private _disabled?;
}
export namespace Page {
    /** Options to be set on the `.displayOptions` object property of a component, if any, to define its positioning and behavior when displayed directly on a page */
    interface DisplayOptions {
        /** Set to true to add a backdrop behind this component */
        shade?: boolean;
        /** Set to true to float this component on top of previous components on the page, and block input to components below */
        modal?: boolean;
        /** Set to true to keep this component on top of all other components; only relevant if `.modal` is also true */
        stayOnTop?: boolean;
        /** Vertical alignment of this component relative to the page; only relevant if `.modal` is also true */
        modalVertAlign?: "top" | "middle" | "bottom";
        /** Horizontal alignment of this component relative to the page; only relevant if `.modal` is also true */
        modalHorzAlign?: "left" | "center" | "right";
        /** Margin around the side(s) of this component that are aligned to the side(s) of the screen (CSS length value, defaults to 0) */
        alignMargin?: string;
        /** Margin around the side(s) of this component that are away from the side(s) of the screen (CSS length value, defaults to 0) */
        outerMargin?: string;
        /** Callback invoked when the user clicks or touches outside of this component, presses a modal-close button, or presses the escape key */
        onEsc?: () => void;
    }
}
/** Class definition for a signal that is emitted on a Page instance */
export class PageSignal<T> extends Async.Signal<T> {
    /** The page for which this event is emitted */
    static page: Page;
}

}

declare module "@typescene/ui/UI/PopOver" {
import { Animation, Component, Container, TextLabelFactory } from "@typescene/ui/UI";
/** Contains methods for displaying modal popovers */
export namespace PopOver {
    /** Display a popover containing given container, below given reference component */
    function displayBelow(ref: Component, container: Container, options?: PopOver.Options): void;
    /** Display a popover containing given container, above given reference component */
    function displayAbove(ref: Component, container: Container, options: PopOver.Options): void;
    /** Dismiss the popover currently on screen, if any */
    function dismiss(): void;
    /** Contains popover display options */
    interface Options {
        title?: string | TextLabelFactory;
        hideArrow?: boolean;
        animation?: Animation;
    }
}

}

declare module "@typescene/ui/UI/Screen" {
import * as Async from "@typescene/async";
import { Component, Page } from "@typescene/ui/UI";
/** Methods for managing the available (fixed) screen space in the application viewport */
export namespace Screen {
    /** Display given view in the foreground, replacing the current page or adding to it (or to a new blank page, if none was displayed) */
    function display(view: Component | Page): void;
    /** Remove given component from the page (i.e. the page it was _last displayed_ on using the `.display(...)` method) */
    function remove(view: Component): any;
    /** Remove given page from the screen, if it is currently displayed */
    function remove(view: Page): any;
    /** Promise that resolves to true when ready to display the UI, after all static resources have been loaded */
    const ready: PromiseLike<true>;
    /** Viewport dimensions (sealed observable object) */
    const dimensions: Dimensions & Async.ObservableObject;
    /** Type definition for the `Screen.dimensions` observable object */
    interface Dimensions extends Async.ObservableObject {
        /** Number of logical pixels available on horizontal axis (observable) */
        readonly width: number;
        /** Number of logical pixels available on vertical axis (observable) */
        readonly height: number;
        /** True if viewport width is less than EXTRASMALL_WIDTH; implies that .isSmall is also true (observable) */
        readonly isExtraSmall: boolean;
        /** True if viewport width is less than SMALL_WIDTH (observable) */
        readonly isSmall: boolean;
        /** True if viewport width is LARGE_WIDTH or above (observable) */
        readonly isLarge: boolean;
        /** True if viewport width is EXTRALARGE_WIDTH or above; implies that .isLarge is also true (observable) */
        readonly isExtraLarge: boolean;
    }
    /** "Extra small" horizontal root width in logical pixels, default 550 */
    var EXTRASMALL_WIDTH: number;
    /** "Small" horizontal root width in logical pixels, default 720 */
    var SMALL_WIDTH: number;
    /** "Large" horizontal root width in logical pixels, default 960 */
    var LARGE_WIDTH: number;
    /** "Extra large" horizontal root width in logical pixels, default 1200 */
    var EXTRALARGE_WIDTH: number;
}

}

declare module "@typescene/ui/UI/Style" {
import * as Async from "@typescene/async";
/** Encapsulates CSS style properties, classes, and hidden/selected attributes; these styles are observed when applied to components on screen, by themselves or overridden using another Style instance (see `.override(...)`); properties are always applied in alphabetical order, i.e `backgroundColor` after `background`, `paddingTop` after `padding`, etc. */
export class Style {
    /** Create a Style instance that only contains given class name(s); alias for new Style(undefined, className) */
    static withClass(className: string): Style;
    /** Create a new instance with given styles; class name argument may contain multiple class names separated with spaces */
    constructor(styles?: Style.StyleSet, className?: string, hidden?: boolean);
    /** Globally unique ID for this Style instance */
    readonly uid: string;
    /** Add the given class name(s); returns this */
    addClass(...classNames: string[]): this;
    /** Remove the given class name(s), from this instance as well as any instances that this instance overrides; returns this */
    removeClass(...classNames: string[]): this;
    /** Remove (all) existing CSS class name(s) and use given class(es) (only on this Style instance, not on overriding or overridden styles); returns this */
    setClass(...classNames: string[]): this;
    /** Returns the current CSS class name(s) stored in this instance (observable) */
    getClassName(): string;
    /** Returns the full CSS text for all properties set/overridden */
    getCSSText(): string;
    /** Returns value for given property; the property must be set explicitly on this Style instance or overriding Style instances */
    get(propertyName: string): any;
    /** Add a drop shadow effect, with given depth factor (0-1); returns this */
    addShadowEffect(depth: number | Async.ObservableValue<number>): this;
    /** Add the "hidden" attribute; returns this */
    hide(): this;
    /** Map the "hidden" attribute to the value of given observable; returns this */
    hide(hidden?: boolean | Async.ObservableValue<boolean>): any;
    /** Remove the "hidden" attribute; returns this */
    show(): this;
    /** Returns hidden state for this Style instance, true if explicitly hidden, false if explicity shown, undefined otherwise (observable) */
    isHidden(): any;
    /** Add the "selected" attribute; returns this */
    select(): any;
    /** Map the "selected" attribute to the value of given observable; returns this */
    select(selected?: boolean | Async.ObservableValue<boolean>): any;
    /** Remove the "selected" attribute; returns this */
    deselect(): this;
    /** Returns selection state for this Style instance, true if explicitly selected, false if explicity deselected, undefined otherwise (observable) */
    isSelected(): any;
    /** Set a style property; if given value is observable, this value will be observed while this Style instance is applied to an element on screen; returns this */
    set(propertyName: string, value: string | Async.ObservableValue<string>): this;
    /** Set multiple style properties using values (strings or `ObservableValue` instances) in given object; if given object is an `ObservableObject`, only _existing observable_ properties are observed; returns this */
    set(obj: Style.StyleSet | Async.ObservableObject): this;
    /** Override styles and classes with those from given Style instance; returns this */
    override(style?: Style | Style.StyleSet | Async.ObservableObject | Async.ObservableValue<Style | Style.StyleSet | Async.ObservableObject | undefined>): this;
    /** Returns a list that consists of this Style instance itself, plus any recursively overriding Style instances in effect; except for instances without any non-empty properties or classes (observable) */
    getOverrides(): Style[];
    /** Helper method to set an observable property on `._props` to given value and set `._status` accordingly; creates the `._props` object, makes the property observable, and adds the property name to the `._keys` array if needed (but does NOT sort it) */
    private _setProperty(name, value?);
}
export namespace Style {
    /** A set of styles: properties with CSS values, e.g. { textAlign: "left" }; the operator "||" may be used within CSS value strings to indicate fallbacks for older platforms, e.g. "start || left" where "left" is applied before "start" */
    interface StyleSet {
        [cssProperty: string]: string | Async.ObservableValue<string>;
    }
}

}

declare module "@typescene/app/App/Activity/Activity" {
import * as Async from "@typescene/async";
import { ActivityResourcePath } from "@typescene/app/App/Activity/ActivityPath";
import { ActivitySignal, ActivityTransition } from "@typescene/app/App/Activity";
/** Represents a UI activity */
export class Activity extends Async.ObservableObject {
    /** Get an instance of this activity class, can be overridden to alter behavior when e.g. pushing a parent activity by class; by default simply constructs the instance without parameters */
    static getInstance(): Activity;
    /** Create an activity with given display title */
    constructor(title?: string);
    /** Display title of this activity (observable) */
    title: string | undefined;
    /** Object that represents the internal state of the activity; this is a sealed observable object, never null or undefined, and setting this to a plain object ({...}) will create an ObservableObject instance (in practice, initialize all properties as activity.state = { x: ... } first to make properties observable); it is recommended to keep properties on the state object instead of on the Activity instance itself, and provide public access through the derived Activity's methods (e.g. to view instances) */
    protected state: {};
    /** Object that contains options for this activity (observable, not null or undefined) */
    options: Activity.ActivityOptions;
    /** Signal that is emitted before this activity is pushed to foreground, if any handler throws an error then the activity is not activated */
    readonly Activating: Async.Signal.Emittable<ActivityTransition, typeof ActivitySignal>;
    /** Signal that is emitted after this activity is pushed to foreground */
    readonly Activated: Async.Signal.Emittable<ActivityTransition, typeof ActivitySignal>;
    /** Signal that is emitted before another activity is pushed to foreground, if any handler throws an error then the activity is not suspended */
    readonly Suspending: Async.Signal.Emittable<ActivityTransition, typeof ActivitySignal>;
    /** Signal that is emitted when this activity is no longer in foreground */
    readonly Suspended: Async.Signal.Emittable<ActivityTransition, typeof ActivitySignal>;
    /** Signal that is emitted before this activity is put back in foreground, if any handler throws an error then the activity is not suspended */
    readonly Resuming: Async.Signal.Emittable<ActivityTransition, typeof ActivitySignal>;
    /** Signal that is emitted when this activity is back in foreground */
    readonly Resumed: Async.Signal.Emittable<ActivityTransition, typeof ActivitySignal>;
    /** Signal that is emitted after this activity is removed from history */
    readonly Deactivated: Async.Signal.Emittable<ActivityTransition, typeof ActivitySignal>;
}
export namespace Activity {
    /** Options for an activity that determine its behavior in the activity stack */
    interface ActivityOptions {
        /** The parent activity, if any; the activity stack will ensure the given activity (or an instance of given class) exists in its history stack when activating this activity, or insert it before */
        parentActivity?: Activity | typeof Activity;
        /** Set to true to require this activity to be in the foreground, or move up to it, when used as a parent activity; i.e. when starting or resuming a child activity, all activities on top of the hub activity are suspended and replaced with the child activity; can be used to prevent buildup of activities on the history stack and therefore memory leaks */
        isHubActivity?: boolean;
        /** Set to true to allow only one copy of an activity on the stack; i.e. when pushing an instance that is already on the stack, the stack is transitioned up to the existing instance instead; use with a singleton activity to implement e.g. an application home activity */
        isRootActivity?: boolean;
        /** Set to true to mark this activity as a background activity; i.e. it should not be started directly, and it should be skipped when navigating back in history (enforced by `Application`, not `ActivityStack` itself, to allow background activities in the foreground temporarily, and to enable skipping past a first background activity on the stack by exiting the application) */
        isBackgroundActivity?: boolean;
    }
}
/** Represents an activity pertaining to a resource (URL path) */
export class ResourceActivity extends Activity {
    /** Create an activity with given resource path */
    constructor(title?: string, path?: ActivityResourcePath | string);
    /** The path (URL/hash segment) that is associated with this activity */
    resourcePath: ActivityResourcePath | string | undefined;
}

}

declare module "@typescene/app/App/Activity/ActivityPath" {
import Async from "@typescene/async";
import { Activity, ResourceActivity } from "@typescene/app/App/Activity/Activity";
export type PathInitializerPart = ResourceActivity | ActivityResourcePath | string;
/** Represents a resource path (URL/hash segment) that is handled by one or more activities */
export class ActivityResourcePath {
    /** Create a new resource path from given parts (string, ResourceActivity instance, or another resource path) */
    constructor(...parts: PathInitializerPart[]);
    /** Append a part to the end of this path and return new path */
    concat(...parts: PathInitializerPart[]): ActivityResourcePath;
    /** Returns the URL that can be used e.g. in href attributes; does not contain final slash so can be concatenated */
    toString(): any;
    /** Check if given URL or path (e.g. http://... or /... or #/...) matches this path (or a sub path); returns matching prefix and remainder if matched successfully, undefined otherwise */
    match(location: string): ActivityResourcePath.Match | undefined;
    private _parts;
}
export namespace ActivityResourcePath {
    /** Information for a resource path match */
    interface Match {
        /** The path name or hash prefix that was matched */
        location: string;
        /** The remainder of the location after the matching prefix, without leading slash (if any) */
        remainder: string;
        /** True if location matched by hash (part after #/...) */
        isHash: boolean;
    }
}
/** Represents a mapping of paths to activity providers (routes) */
export class ActivityResourceMap {
    /** Add a route that invokes given callback with parameters that correspond to the parts of the path remainder when current location matches with given path (#/... or /...); the final parameter is set to all remaining parts joined with slashes (glob); if the callback has no parameters, an exact match is required; returns a signal connection that can be used to unregister */
    register(path: PathInitializerPart | PathInitializerPart[], callback: (...params: string[]) => Activity | Activity[] | PromiseLike<Activity | Activity[]> | undefined): Async.SignalConnection;
    /** Get a promise that resolves to a list of activities that are registered for given path (#/... or /... or full href, %-decoded) */
    obtainAsync(location: string | ActivityResourcePath): PromiseLike<Activity[]>;
    /** Get a function that matches a location with given resource path and calls callback with location remainder */
    private _getMatcher(resourcePath, callback);
    private _Signal;
}

}

declare module "@typescene/app/App/Activity/ActivityStack" {
import * as Async from "@typescene/async";
import { Component } from "@typescene/ui";
import { Activity } from "@typescene/app/App/Activity/Activity";
/** Represents a stack of activated activities (like browser history) */
export class ActivityStack {
    /** Set to true to enable trace logging (on `console.log`) for activity operations */
    static TRACE_LOG: boolean;
    /** Add an activity to the foreground asynchronously, does nothing if given activity was already in the foreground; returns Promise that resolves to the completed transition */
    pushAsync(activity: Activity): PromiseLike<ActivityTransition>;
    /** Replace the current activity asynchronously (throws error if none), or remove current activity if given activity was already directly below current activity in the activity stack; returns Promise that resolves to the completed transition */
    replaceAsync(activity: Activity): PromiseLike<ActivityTransition>;
    /** Remove the current foreground activity (go back) asynchronously, returns Promise that resolves to the completed transition */
    popAsync(): PromiseLike<ActivityTransition>;
    /** Remove the current foreground activity (go back) asynchronously if and only if it is the given activity, returns Promise that resolves to the completed transition, if any */
    popAsync(activity: Activity): PromiseLike<ActivityTransition | null>;
    /** Remove foreground activities until given activity or activity of given type is in the foreground; returns Promise that resolves to activity, or null if there was no matching activity on the stack */
    upAsync(activityOrClass: Activity | typeof Activity): PromiseLike<Activity | null>;
    /** Reload state using given history ID, if possible (i.e. not yet deactivated relevant activities in the meantime); returns a promise that resolves when the state has been reached */
    restoreHistoryStateAsync(historyID: string): PromiseLike<void>;
    /** Get an ID that represents the current state, for use with `.restoreHistoryStateAsync` */
    getHistoryState(): string;
    /** Get the activity closest to the foreground of the given type, if any (excluding foreground activity itself, and before given activity in second parameter, if any) */
    getParent<T>(ActivityClass: typeof Activity & {
        new (...args): T;
    }, before?: Activity): T | undefined;
    /** Get Component instance for given named outlet, from the view activity closest to the foreground that has given outlet mapped using `.mapView(...)` or the `mapToActivity(...)` decorator on a view Component class */
    getViewComponent(outlet: string): Component | undefined;
    /** Returns true if the stack contains given activity */
    contains(activity: Activity): boolean;
    /** The current foreground activity (top of stack, if any; observable) */
    readonly top: Activity | undefined;
    /** The number of activities on the stack (observable) */
    readonly length: number;
    /** The title of the topmost activity that has a title defined (observable) */
    readonly title: string | undefined;
    /** Signal that is emitted when a transition occurs (after Activating/Resuming/Suspending but before Activated/Resumed) */
    readonly Transition: Async.Signal.Emittable<ActivityTransition, typeof ActivitySignal>;
    /** Helper method to find parent activity/ies for given activity; returns an array of activities to be pushed (including activity itself) */
    private _findParents(activity, excludeTop?);
    /** Helper method to move up to existing root activity, or hub parent activity if needed */
    private _upToHubOrRoot(activity);
    /** Helper method for sending signals and creating promise */
    private _processTransition(to, operation);
    private _ids;
    private _transitionP;
}
/** Represents a transition from one foreground activity to another */
export interface ActivityTransition {
    /** Unique ID for this transition */
    id: string;
    /** The activity stack that is transitioning */
    activityStack: ActivityStack;
    /** The activity that is currently in the foreground, if any */
    from: Activity;
    /** The new foreground activity, if any */
    to: Activity;
    /** The stack operation being performed: push, replace, or pop */
    operation: ActivityTransition.Operation;
    /** The previous transition that is part of the same operation (pop/push/pop/up) */
    previous: ActivityTransition;
}
export namespace ActivityTransition {
    /** Operation type that triggered a transition */
    enum Operation {
        /** Push operation */
        Push = 0,
        /** Replace operation */
        Replace = 1,
        /** Pop operation */
        Pop = 2,
    }
}
/** Signal that is emitted when a change in the activity stack occurs */
export class ActivitySignal extends Async.Signal<ActivityTransition> {
}

}

declare module "@typescene/app/App/Activity" {
export * from "@typescene/app/App/Activity/Activity";
export * from "@typescene/app/App/Activity/ActivityStack";
export * from "@typescene/app/App/Activity/ActivityPath";
export * from "@typescene/app/App/Activity/ViewActivity";

}

declare module "@typescene/app/App/Activity/ViewActivity" {
import * as Async from "@typescene/async";
import { Component, Page } from "@typescene/ui";
import { Activity, ResourceActivity } from "@typescene/app/App/Activity/Activity";
import { ActivityResourcePath } from "@typescene/app/App/Activity/ActivityPath";
import { ActivityTransition } from "@typescene/app/App/Activity";
/** Represents an activity that corresponds to a (component or Page on) screen */
export class ViewActivity extends ResourceActivity {
    /** Create a view activity with optional title and view instance, parent reference, and resource path; to add a view component/page dynamically, use the `mapToActivity(...)` decorator on a view Component or Page class, or call the `.mapView(...)` method on this activity */
    constructor(title?: string, path?: ActivityResourcePath | string, view?: Component | Page, parent?: Activity | typeof Activity);
    /** The main view component/page that is currently displayed, if any; this is a readonly field, to link a view to an activity use the `mapToActivity(...)` decorator on a view Component or Page class, or call the `.mapView(...)` method on a view activity */
    readonly view: Component | Page | undefined;
    /** Signal that is emitted before this activity's view is displayed in the foreground (i.e. NOT if displayed as parent view) */
    readonly Displaying: Async.Signal.Emittable<ViewActivityTransition, typeof ViewActivitySignal>;
    /** Signal that is emitted after this activity is displayed in the foreground (i.e. NOT if displayed as parent view) */
    readonly Displayed: Async.Signal.Emittable<ViewActivityTransition, typeof ViewActivitySignal>;
    /** Register given function to return the view instance for given outlet name, or for the main view if none given; existing getter for the same outlet is replaced, if any; getter must always return a component/page instance, which may be the same instance every time; the function may accept a single parameter, which is the foreground activity (i.e. this activity, or another `ViewActivity` instance that refers to this activity as a parent activity) */
    mapView(f: (fg: ViewActivity) => (Component | Page), outlet?: string): void;
    /** Get an instance of the view component/page for given named outlet on this activity, or main view if none given, by calling the mapped view getter that has been registered through the `.mapView(...)` method (within unobserved function wrapper to avoid observable side effects) */
    getViewByName(outlet?: string): Component | Page | undefined;
    /** Display the view (component on the current page, or a new page) */
    private _displayMainView(resumed, t, child?);
    /** View getter(s), registered through mapView method */
    private _viewGetters;
    /** View currently displayed */
    private _view;
    /** Counter that goes up every time the main view is displayed */
    private _count;
}
/** Represents an activity that corresponds to a component or page on screen, created only once and re-used if required (overrides .getInstance static method); abstract class, needs to be overridden */
export abstract class SingletonViewActivity extends ViewActivity {
    /** Get the instance of this activity class, constructs the instance without parameters once and returns this instance every time */
    static getInstance(): SingletonViewActivity;
    /** Create a new activity; can be used only once */
    constructor(title?: string, path?: ActivityResourcePath | string, view?: Component | Page, parent?: Activity | typeof Activity);
    private static _instance;
}
/** Represents a singleton view activity that is both a root activity (i.e. may exist only once on the activity stack, starting/replacing the activity again transitions the stack up to the existing activity instead), and a hub activity (i.e. starting any activity that specifies this activity as its parent activity, transitions the stack up to the hub activity first, suspending all other activities that used to be in the foreground); abstract class, needs to be overridden */
export abstract class RootViewActivity extends SingletonViewActivity {
    constructor(title?: string, path?: ActivityResourcePath | string, view?: Component | Page);
}
/** Represents a transition from one (view) activity to a view activity that is to be displayed, encapsulates activity transition */
export interface ViewActivityTransition {
    /** The activity transition itself */
    transition: ActivityTransition;
    /** The main view, if any, displayed as a result of this transition */
    view: Component | Page | undefined;
    /** True if displaying this view for the first time (i.e. the activity has just been added, and not resumed or added again) */
    firstDisplay: boolean;
    /** True if adding this view to the browser history (i.e. not resuming from history) */
    forward: boolean;
    /** Number of transitions in the current chain (for checking if e.g. a dropActivity(...) call crossed multiple activities to get to this view) */
    hops: number;
}
/** Signal that is emitted when a change in the activity stack occurs */
export class ViewActivitySignal extends Async.Signal<ViewActivityTransition> {
}
/** *Class decorator*, maps the decorated view Component class (with a constructor that has a single matching activity argument) to a ViewActivity class as given named outlet, or as the main view if none specified; view instances are re-used when possible, but are dereferenced within given timeout when no longer in use (in ms, defaults to 2s, set to 0 to disable) [decorator] */
export function mapToActivity<ActivityT extends ViewActivity, ComponentT extends Component>(activityClass: {
    new (...args: any[]): ActivityT;
}, outlet?: string, dereferenceTimeout?: number): (target: {
    new (activity: ActivityT): ComponentT;
}) => void;
/** *Class decorator*, maps the decorated view Page class (with a constructor that has a single matching activity argument) to a ViewActivity class as given named outlet, or as the main view if none specified; view instances are re-used when possible, but are dereferenced within given timeout when no longer in use (in ms, defaults to 2s, set to 0 to disable) [decorator] */
export function mapPageToActivity<ActivityT extends ViewActivity, ComponentT extends Component>(activityClass: {
    new (...args: any[]): ActivityT;
}, outlet?: string, dereferenceTimeout?: number): (target: {
    new (activity: ActivityT): ComponentT;
}) => void;

}

declare module "@typescene/app/App/Application" {
import * as Async from "@typescene/async";
import { Component } from "@typescene/ui";
import { Activity, ResourceActivity, ActivityTransition, ActivityStack, ActivityResourcePath, PathInitializerPart } from "@typescene/app/App/Activity";
/** Encapsulates the application as a singleton object */
export class Application extends Async.ObservableObject {
    /** Map resource activity on its path (using .resourcePath) */
    static mapActivity(activity: ResourceActivity): void;
    /** Map given path (#/... or /...) to given activity (i.e. instance or instance of class through static getInstance method) */
    static mapActivity(path: PathInitializerPart | PathInitializerPart[], activity?: Activity | typeof Activity): void;
    /** Map given path (#/... or /...) to given callback; if callback has no parameters, an exact path match is required; otherwise callback is called with path remainder split on / characters plus glob (last parameter); callback should return an activity or array of activities (or a promise that resolves to either), returned ResourceActivity instances without a resource path will get the requested path set as their resource path automatically */
    static mapResource(path: PathInitializerPart | PathInitializerPart[], callback: (...params: string[]) => Activity | Activity[] | PromiseLike<Activity | Activity[]> | undefined): Async.SignalConnection;
    /** Disable synchronization of activity stack with browser history */
    static disableBrowserHistory(): void;
    /** The current (and only) Application instance, when created */
    static current: Application;
    /** Promise that resolves to the application instance after it has been created */
    static ready: PromiseLike<Application>;
    private static _resolve_ready;
    /** Create the application instance (either from a derived class or from the Application class itself); can be called only once */
    constructor(title?: string);
    /** The application name to be displayed in the title bar (observed), overridden by the title of the current activity/ies, if any */
    title: string;
    /** Signal that is emitted when no activity is found for a location */
    readonly PageNotFound: Async.Signal.Emittable<string, typeof ApplicationSignal>;
    /** Signal that is emitted when all activities have been dropped and none have been started */
    readonly NoActivity: Async.Signal.Emittable<void, typeof ApplicationSignal>;
    /** Activity stack instance */
    activities: ActivityStack;
    /** Map resource activity on its path (using .resourcePath); returns this; also available as a static method */
    mapActivity(activity: ResourceActivity): void;
    /** Map given path (#/... or /...) to given activity (i.e. instance or instance of class through static getInstance method); returns this; also available as a static method */
    mapActivity(path: PathInitializerPart | PathInitializerPart[], activity?: Activity | typeof Activity): void;
    /** Map given path (#/... or /...) to given callback; if callback has no parameters, an exact path match is required; otherwise callback is called with path remainder split on / characters except last parameter (glob); callback should return an activity or array of activities (or a promise that resolves to either), returned ResourceActivity instances without a resource path will get the requested path set as their resource path automatically; returns this; also available as a static method */
    mapResource(path: PathInitializerPart | PathInitializerPart[], callback: (...params: string[]) => Activity | Activity[] | PromiseLike<Activity | Activity[]>): this;
    /** Get Component instance for given named outlet, from the view activity closest to the foreground that has given outlet mapped using `.mapView(...)` or the `mapToActivity(...)` decorator on a view Component class; can be used as an observable getter to obtain an observable value that changes when activities are started or suspended */
    getViewComponent(outlet: string): Component | undefined;
    /** Returns the activity that is currently in the foreground (observable) */
    getTopActivity(): Activity | undefined;
    /** Start given activity as foreground activity (push/replace, same as calling .activities.push/replace(...) directly), or start activity using given resource path or string (#/... or /..., or relative path as #./..., #../..., ./... or ../...); if setHrefIfNotFound is not false, then window.location.href is set to the new location if no matching activity is found (automatic for external URLs), otherwise invokes onPageNotFound handler; note that activities transition asynchronously and any updates may not be reflected until several milliseconds after calling this method */
    startActivity(activityOrPath: Activity | typeof Activity | ActivityResourcePath | string, replace?: boolean, setHrefIfNotFound?: boolean): PromiseLike<ActivityTransition[]>;
    /** Go back in activity history; either to previous activity or to activity of given class; returns promise that resolves to the new foreground activity, or null if activity was not found; the NoActivity signal is emitted if all activities have been dropped and there is no current activity anymore */
    dropActivity(ActivityClass?: typeof Activity): PromiseLike<Activity | null>;
    /** Returns true if the given path matches or is a prefix of the currently active path (e.g. `#/items` is considered active if the current path is `#/items/123` or `#/items`) */
    isActive(path: ActivityResourcePath | string): boolean;
    /** Returns true if the current activity or one of its parent activities is an instance of the given activity class */
    isActive(activityClass: typeof Activity): boolean;
    /** Returns true if the given activity matches the current activity or one of its parent activities */
    isActive(activity: Activity): boolean;
    private _listen();
    private _startLocationActivity(replace?);
    private _updateHistoryState(op?);
}
/** *Class decorator*, maps the decorated Activity class to given path (using `Application.mapActivity` method) [decorator] */
export function mapToPath(path: PathInitializerPart | PathInitializerPart[]): (target: typeof Activity) => void;
/** *Class decorator*, maps the decorated Activity class to simple sub resources on given path (using `Application.mapResource` method, use that method directly for more options), but not the path itself; the activity class *must* have a constructor that takes a single string parameter, i.e. the resource path glob [decorator] */
export function mapToResource(path: PathInitializerPart | PathInitializerPart[]): (target: new (glob: string) => Activity) => void;
/** Alias for `Application#startActivity` on the current Application instance; if there is no current instance, this function waits for the instance to be created first */
export function startActivity(activityOrPath: Activity | typeof Activity | ActivityResourcePath | string, replace?: boolean, setHrefIfNotFound?: boolean): PromiseLike<ActivityTransition[]>;
/** Get the activity closest to the foreground of given type, if any */
export function findActivity<T>(ActivityClass: typeof Activity & {
    new (...args): T;
}): T | undefined;
/** A signal that is emitted by `Application` */
export class ApplicationSignal extends Async.Signal<string> {
}

}

declare module "@typescene/app/App/Http" {
import { Signal } from "@typescene/async";
/** Namespace that encapsulates `.fetch` and related functionality */
export namespace Http {
    /** Configuration options */
    var config: GlobalConfig;
    /** Configuration options (for exported `config` variable) */
    interface GlobalConfig {
        /** Force `fetch` to use XMLHttpRequest instead of native `fetch` implementation (defaults to false) */
        FORCE_XHR_FETCH: false;
        /** Automatically set `fetch` credentials mode to "include" (defaults to true) */
        FETCH_INCLUDE_CREDENTIALS: true;
    }
    /** Signal that is emitted before sending a request; can be used to intercept requests, modify request options, and provide an alternate response; if one of the connected handlers returns a (promise for) an alternate response, i.e. an object that implements `FetchResponse`, then the request will not be sent, and the (first) resulting alternate response is used instead; if one of the connected handlers throws an exception, the original promise for the request is rejected; otherwise the request is sent as per normal */
    var Requesting: Signal.Emittable<FetchOptions, typeof Signal>;
    /** Signal that is emitted after obtaining a remote response (from an actual request, not an alternate response provided by a connected handler of `.Requesting`) */
    var Responded: Signal.Emittable<FetchResponse, typeof Signal>;
    /** Definition of a collection of HTTP headers as an object */
    interface Headers {
        [headerName: string]: string;
    }
    /** Interface definition for the simple read-only methods of a native Headers instance */
    interface FetchHeaders {
        /** Returns the first value of a single header by name */
        get(name: string): string;
        /** Returns all values of a single header by name (e.g. `Accept-Encoding`) */
        getAll(name: string): string[];
        /** Returns true if this instance contains the given header */
        has(name: string): boolean;
        /** Returns an iterator that lists all headers by name (polyfill only supports manual iteration with the `next` method for compatibility) */
        keys(): {
            next(): {
                done?: boolean;
                value?: string;
            };
        };
    }
    /** Interface definition for supported fetch options */
    interface FetchOptions {
        /** The HTTP method (GET, PUT, POST, DELETE, etc) */
        method?: string;
        /** The URL to send a request to */
        url?: string;
        /** Request headers (object literal or native Headers instance) */
        headers?: Headers | FetchHeaders;
        /** Request body (string, or possibly a Blob if using the native `fetch` implementation) */
        body?: string | Blob;
    }
    /** Interface definition for Response properties available in the native Fetch implementation as well as the polyfill implementation */
    interface FetchResponse {
        /** Headers returned to the client */
        readonly headers: FetchHeaders;
        /** True if the response was successful (status 200-299) */
        readonly ok: boolean;
        /** Status code of the response */
        readonly status: number;
        /** Status message */
        readonly statusText: string;
        /** Returns a promise for the response body read into a Blob, if supported */
        blob(): PromiseLike<Blob>;
        /** Returns a promise for the response body */
        text(): PromiseLike<string>;
        /** Returns a promise for the response body, parsed as JSON */
        json(): PromiseLike<any>;
    }
    /** Implements the FetchResponse interface, can be used to mock responses or initialize a response from an XMLHttpRequest */
    class MockResponse implements FetchResponse {
        /** Create a response with given data encoded as JSON, the `application/json` content type, and status 200 */
        static withJSONContent(data: any): MockResponse;
        /** Create a response with given properties (an XMLHttpRequest object can be passed in directly, along with a native fetch `Headers` instance or a MockResponseHeaders instance); the response itself is taken from `.responseText` if it is not undefined, or from `.response` if it is a Blob */
        constructor(init?: {
            status?: number;
            statusText?: string;
            responseText?: string;
            response?: Blob;
        }, headers?: FetchHeaders);
        /** Headers returned to the client */
        readonly headers: FetchHeaders;
        /** True if the response was successful (status 200-299) */
        readonly ok: boolean;
        /** Status code of the response */
        readonly status: number;
        /** Status message */
        readonly statusText: string;
        /** Returns a promise for the response body read into a Blob, if supported */
        blob(): PromiseLike<Blob>;
        /** Returns a promise for the response body */
        text(): PromiseLike<string>;
        /** Returns a promise for the response body, parsed as JSON */
        json(): PromiseLike<any>;
        /** Helper method that returns a Promise with the text from the constructor initializer (with text in `.responseText`, or a blob in `.response`) */
        private _readText();
    }
    /** Implements the FetchResponse interface, can be used to mock response headers or initialize response headers from an XMLHttpRequest */
    class MockResponseHeaders implements FetchHeaders {
        /** Initialize the list of headers using given HTTP header text (i.e. one or more lines with header name, colon, and header value; strips all whitespace around names and values) */
        constructor(allResponseHeaders?: string);
        private _headers;
        get(name: string): any;
        getAll(name: string): any;
        has(name: string): boolean;
        keys(): {
            next: () => {
                done?: boolean | undefined;
                value?: string | undefined;
            };
        };
    }
    /** Perform a request to fetch a resource at given URL; provides a partial polyfill for the Fetch standard using XMLHttpRequest, but uses native `fetch()` internally if available */
    function fetch(inputUrl: string, init?: FetchOptions): PromiseLike<FetchResponse>;
    /** Perform a request to fetch a resource; provides a partial polyfill for the Fetch standard using XMLHttpRequest, but uses native `fetch` internally if available */
    function fetch(inputRequest: any): PromiseLike<FetchResponse>;
    /** Perform a GET request with given parameters and headers, if any; returns a promise that resolves to the response text, or gets rejected if the request fails or response status is not in 2xx range */
    function getTextAsync(url: string, params?: any, headers?: Headers | FetchHeaders): PromiseLike<string>;
    /** Perform a GET request with given parameters and headers, if any; returns a promise that resolves to a blob, or gets rejected if the request fails or response status is not in 2xx range; requires a browser that supports Blob constructors */
    function getBlobAsync(url: string, params?: any, headers?: Headers | FetchHeaders): PromiseLike<Blob>;
    /** Perform a GET request with given parameters and headers, if any; returns a promise that resolves to the parsed HTML result body as a document fragment (ignores everything before and after body tag, if any; inserts everything if no body tag is found, i.e. partial HTML), or gets rejected if the request fails or response status is not in 2xx range */
    function getHtmlContentAsync(url: string, params?: any, headers?: Headers | FetchHeaders): PromiseLike<DocumentFragment>;
    /** Perform a GET request with given parameters and headers, if any; returns a promise that resolves to the parsed JSON response (or undefined if response was empty), or gets rejected if the request fails or response status is not in 2xx range */
    function getAsync(url: string, params?: any, headers?: Headers | FetchHeaders): PromiseLike<any>;
    /** Perform a POST request with given object (sent as JSON) and headers, if any; returns a promise that resolves to the parsed JSON response (or undefined if response was empty), or gets rejected if the request fails or response status is not in 2xx range */
    function postAsync(url: string, data?: any, headers?: Headers): PromiseLike<FetchResponse>;
    /** Perform a PUT request with given object (sent as JSON) and headers, if any; returns a promise that resolves to the parsed JSON response (or undefined if response was empty), or gets rejected if the request fails or response status is not in 2xx range */
    function putAsync(url: string, data?: any, headers?: Headers): PromiseLike<FetchResponse>;
    /** Perform a DELETE request with given object (sent as JSON) and headers, if any; returns a promise that resolves to the parsed JSON response (or undefined if response was empty), or gets rejected if the request fails or response status is not in 2xx range */
    function deleteAsync(url: string, data?: any, headers?: Headers): PromiseLike<FetchResponse>;
}

}

declare module "@typescene/app/App" {
export * from "@typescene/app/App/Activity";
export * from "@typescene/app/App/Application";
export * from "@typescene/app/App/Http";

}

declare module "@typescene/app" {
export * from "@typescene/app/App";
import * as App from "@typescene/app/App";
export default App;

}

declare module "@typescene/typescene" {
// import all packages
import * as _UI from "@typescene/ui";
import * as _Async from "@typescene/async";
import * as _App from "@typescene/app";

// export defaults separately
export { default as UI } from "@typescene/ui";
export { default as Async } from "@typescene/async";
export { default as App } from "@typescene/app";

/** Default "typescene" export with module members */
export default {
    Async: typeof _Async,
    UI: typeof _UI,
    App: typeof _App
};

}
