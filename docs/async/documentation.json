{"title":"Typescene Async module","toc":["overview","samples","~reference"],"items":[{"name":"Overview","id":"overview","textDocTitle":"Typescene Async module","textSort":"01","text":[{"title":"","content":"<p>This library provides a toolkit for asynchronous programming, primarily for the browser (or other browser-based front end, such as Electron). Its main purpose is to support the development of the Typescene UI toolkit.</p>\n<p>This module exports generic classes and functions that implement common ‘async’ patterns, such as promises, signals, and observables.</p>\n"},{"title":"Structure","content":"<p>The included functions and classes build on one another, in the following order:</p>\n<ul>\n<li><code>defer</code> function — provides a basic queueing mechanism to schedule code asynchronously.</li>\n<li><strong>Signals</strong> — defined using <code>defineSignal</code>, which creates a <em>class</em> that derives from <code>Signal</code>, of which instances can be emitted along with a single value. Like events, but different.</li>\n<li><strong>Promises</strong> — the <code>Promise</code> class provides a <a href=\"http://promisesaplus.com/\" target=\"_blank\">Promises/A+</a> compliant promise implementation, along with some additional convenience methods.</li>\n<li><strong>Observable values</strong> — these are objects wrapped around a single value (in the <code>.value</code> property of an <code>ObservableValue</code> object), which can be subscribed to for capturing changes to this value. In addition, observables can be defined using a getter function, which may use other observable values in turn (making changes cascade asynchronously down a dependency tree when subscribed to; this can be employed to implement composite UIs efficiently).</li>\n<li><strong>Observable arrays</strong> — arrays of observable values, hiding the <code>ObservableValue</code> instances in getters and setters for all array indices of an <code>ObservableArray</code> object.</li>\n<li><strong>Observable objects</strong> — loosely defined objects for which some or all of the properties are made observable (using getters and setters) as properties of an <code>ObservableObject</code>, which also defines a <code>PropertyChange</code> signal to listen for changes without having to subscribe to observable values directly.</li>\n<li><strong>Injection</strong> — this mechanism can be used to inject default (observable) values into a property on <em>all instances</em> of a class.</li>\n</ul>\n<p>Refer to the <a href=\"#/samples\">samples</a> for common usage patterns.</p>\n"},{"title":"What is Typescene?","type":"note","content":"<p>This module is part of the Typescene toolkit, a strongly typed front-end toolkit for modern Web applications built with TypeScript. Read more about Typescene on the project’s <a href=\"http://typescene.org\">website</a>.</p>\n"}],"sourceIdx":48},{"name":"Defer","id":"samples/defer","textSort":"01","text":[{"title":"","content":"<p>The <code>defer</code> function provides a basic queueing mechanism for single-threaded asynchronous behavior.</p>\n<p>Scheduling deferred execution of a piece of code:</p>\n"},{"title":"Example","type":"example","content":"<pre><code class=\"language-typescript\">// outputs first line after second line\nAsync.defer(() =&gt; { console.log(&quot;Hello, future.&quot;) });\nconsole.log(&quot;Wait for it...&quot;);\n</code></pre>\n"}],"sourceIdx":50,"textParent":"samples"},{"name":"Samples","id":"samples","textSort":"02","text":[{"title":"About the Examples","content":"<p>All examples are included here as if they are taken from the body of a sample application, which would import the Typescene async library as follows:</p>\n<pre><code class=\"language-typescript\">import { Async } from &quot;@typescene/typescene&quot;;\n</code></pre>\n<p>As a result, all exported members are prefixed with <code>Async.</code> in the examples.</p>\n"}],"sourceIdx":49,"toc":["samples/defer","samples/signals","samples/promises","samples/observables","samples/injection"]},{"name":"Signals","id":"samples/signals","textSort":"02","text":[{"title":"","content":"<p>Signals are like events, but with a single strongly typed payload.</p>\n<p>Creating a signal and subscribing to it:</p>\n<pre><code class=\"language-typescript\">// define a signal with a payload of type `string`\nvar MySignal = Async.defineSignal&lt;string&gt;();\n\n// connect to this signal\nMySignal.connect(text =&gt; {\n    // text is inferred to be of type `string` here\n    console.log(&quot;Received: &quot; + text);\n    return text.toUpperCase();\n});\n\n// can connect more than once\nMySignal.connect(text =&gt; text.toLowerCase());\n\n// invoke all connected handlers:\nMySignal(&quot;foo&quot;);\n\n// =&gt; Received: foo\n\n// advanced, capture return values with a Promise:\nvar sig = new MySignal(&quot;Text&quot;);\nsig.emit().then(results =&gt; {\n    console.log(&quot;Response: &quot; + results.join(&quot;, &quot;));\n});\n\n// =&gt; Received: Text\n// =&gt; Response: TEXT, text\n</code></pre>\n<p>Using a custom signal base class:</p>\n<pre><code class=\"language-typescript\">// define a static signal class\nclass FooSignal extends Async.Signal&lt;string&gt; {\n    static foo: string;\n}\n\n// define signals that derive from FooSignal\nvar MySignal1 = Async.defineSignal(FooSignal, { foo: &quot;bar&quot; });\nvar MySignal2 = Async.defineSignal(FooSignal, { foo: &quot;baz&quot; });\n\nconsole.log(new MySignal1(&quot;foo&quot;) instanceof FooSignal);\n// =&gt; true\n\n// connections can now access foo, too\nfunction connectTo(s: Async.CustomSignalClass&lt;string, typeof FooSignal&gt;) {\n    s.connect((value, src) =&gt; {\n        // value is inferred to be of type `string` here\n        console.log(&quot;Received: &quot; + value);\n        // src is inferred to be of type `typeof FooSignal` here\n        console.log(&quot;  foo === &quot; + src.foo);\n    });\n}\nconnectTo(MySignal1);\nconnectTo(MySignal2);\nMySignal1(&quot;qux&quot;);\nMySignal2(&quot;quux&quot;);\n\n// output:\n// Received: qux\n//   foo === bar\n// Received: quux\n//   foo === baz\n</code></pre>\n"}],"sourceIdx":51,"textParent":"samples"},{"name":"Promises","id":"samples/promises","textSort":"03","text":[{"title":"","content":"<p>A <code>Promise</code> is a placeholder for a value that will be evaluated in the future (or for another Promise, and so on), which can be ‘rejected’ if the value can no longer be evaluated.</p>\n<p>Creating a promise and waiting for it to be resolved:</p>\n<pre><code class=\"language-typescript\">var p = new Async.Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; resolve(&quot;abc&quot;), 1000);\n});\np.then(v =&gt; { console.log(&quot;Value: &quot;, v) });\n\n// ... which is the same as:\nvar p2 = new Async.Promise(() =&gt;\n    Async.sleep(1000).then(() =&gt; &quot;abc&quot;));\np2.then(v =&gt; { /* ... */ });\n\n// ... or even:\nAsync.sleep(1000, &quot;abc&quot;).then(v =&gt; { /* ... */ });\n</code></pre>\n"}],"sourceIdx":52,"textParent":"samples"},{"name":"Observables","id":"samples/observables","textSort":"04","text":[{"title":"","content":"<p>Observable values are objects wrapped around a single value (in the <code>.value</code> property of an <code>ObservableValue</code> object), which can be subscribed to for capturing changes to this value. In addition, observables can be defined using a getter function, which may use other observable values in turn (making changes cascade asynchronously down a dependency tree when subscribed to.</p>\n<p>Creating a class with observable properties (there are many ways to do this, but here is an elegant solution using decorators):</p>\n<pre><code class=\"language-typescript\">// Example class with observable properties:\nclass MyClass extends Async.ObservableObject {\n    // Observable string\n    @Async.observable\n    public text: string;\n\n    // Observable string, never &quot;undefined&quot;\n    @Async.observable_string\n    public get stringified() { return this.text }\n\n    // Observable array (automatically converts plain arrays)\n    @Async.observable\n    public list: string[] = [];\n}\n\nvar c = new MyClass();\nconsole.log(c.text);  // =&gt; &quot;undefined&quot;\nconsole.log(c.stringified);  // =&gt; &quot;&quot;\n\n// listen for changes:\nAsync.observe(() =&gt; c.stringified + &quot; &quot; + c.list.join(&quot;, &quot;))\n    .subscribe(v =&gt; console.log(&quot;Now: &quot; + v));\n    // =&gt; &quot;Now:  &quot;\n\n// also track changed properties without subscribing:\nc.PropertyChange.connect(p =&gt; {\n    console.log(&quot;Updated: &quot; + p)\n});\n\n// modify properties (does not output anything synchronously)\nc.text = &quot;Hi!&quot;;\nc.list.push(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\n\n// asynchronously outputs: ...\n// &quot;Updated: text&quot;\n// &quot;Hi! a, b, c&quot;\n// &quot;Updated: stringified&quot;\n</code></pre>\n"},{"title":"Performance","content":"<p>A note on performance with <code>ObservableArray</code>: since all array elements are recursively treated and converted to observable versions of arrays and (plain) objects, this may incur a performance hit on larger data structures.</p>\n<p>To alleviate this issue if you only need to observe object references, and not the entire data structure, use the following pattern:</p>\n<pre><code class=\"language-typescript\">const MAX = 50000;\n\n// instead of this, which makes `foo` and `bar` observable recursively:\nvar oa = new Async.ObservableArray();\nfor (var i = 0; i &lt; MAX; i++)\n    oa.push({ num: i, foo: true, bar: [] });\n\nconsole.log(oa[0]);  // =&gt; { num: [getter/setter], ... }\n\n// you may want to use this, if you do not need observable properties:\nvar oa2 = new Async.ObservableArray();\nfor (var i = 0; i &lt; MAX; i++) {\n    var ov = new Async.ObservableValue();\n    ov.shallow = true;\n    ov.value = { num: i, foo: true, bar: [] };\n    oa2.push(ov);\n}\n\nconsole.log(oa2[0]);  // =&gt; { num: 0, foo: true, bar: [] }\n</code></pre>\n"}],"sourceIdx":53,"textParent":"samples"},{"name":"Injection","id":"samples/injection","textSort":"05","text":[{"title":"","content":"<p>The injection mechanism can be used to inject default (observable) values into an observable property on <em>all instances</em> of a class.</p>\n<p>Injecting a default value into a class:</p>\n<pre><code class=\"language-typescript\">class Foo {\n    @Async.injectable\n    public value: number;\n}\n\n// inject a default value\nAsync.inject(Foo, { value: 1 });\n\n// the value can be overridden on each instance\nvar a = new Foo(), b = new Foo();\nconsole.log(a.value, b.value);  // =&gt; 1  1\nb.value = 2;\nconsole.log(a.value, b.value);  // =&gt; 1  2\n\n// injecting another value only affects properties not overridden\nAsync.inject(Foo, { value: 3 });\nvar c = new Foo();\nconsole.log(a.value, b.value, c.value);  // =&gt; 3 2 3\n</code></pre>\n<p>Creating a class with an injectable method:</p>\n<pre><code class=\"language-typescript\">class Bar {\n    @Async.injectable\n    public getValue() { return 1 }\n}\n\n// use the method normally\nvar a = new Bar();\nconsole.log(a.getValue());  // =&gt; 1\n\n// inject overriding methods\nvar old1 = Async.inject(Bar, {\n    getValue: () =&gt; {\n        // call the overridden method first (old1.getValue),\n        // i.e. the method defined in the class\n        var value = old1.getValue.call(this);\n        return value + 1;\n    }\n});\nvar old2 = Async.inject(Bar, {\n    getValue: () =&gt; {\n        // call the overridden method first (old2.getValue),\n        // i.e. the method injected above\n        var value = old2.getValue.call(this);\n        return value * 10;\n    }\n});\n\n// now getValue is chained for all old and new instances\nvar b = new Bar();\nconsole.log(a.getValue(), b.getValue());  // =&gt; 20 20\n</code></pre>\n<p>Injection works as expected with derived classes, too:</p>\n<pre><code class=\"language-typescript\">// define three classes with one injectable method\nclass A {\n    @Async.injectable\n    public foo() { return this._foo };\n    private _foo = &quot;foo&quot;;\n}\n\nclass B extends A { }\nclass C extends B { }\n\n// inject a chained method on the base class A\nvar a1 = Async.inject(A, {\n    foo() { return a1.foo.call(this) + &quot;bar&quot; }\n});\nconsole.log(new A().foo(), new B().foo(), new C().foo());\n// =&gt; foobar foobar foobar\n\n// inject an overriding chained method on C\nvar c1 = Async.inject(C, {\n    foo() { return c1.foo.call(this) + &quot;baz&quot; }\n});\nconsole.log(new A().foo(), new B().foo(), new C().foo());\n// =&gt; foobar foobar foobarbaz\n\n// inject more chained methods on A and B,\n// note that c1.foo above is dynamic\nvar b1 = Async.inject(B, {\n    foo() { return b1.foo.call(this) + &quot;quux&quot; }\n});\nvar a2 = Async.inject(A, {\n    foo() { return a2.foo.call(this) + &quot;qux&quot; }\n});\nconsole.log(new A().foo(), new B().foo(), new C().foo());\n// =&gt; foobarqux foobarquxquux foobarquxquuxbaz\n</code></pre>\n"}],"sourceIdx":54,"textParent":"samples"},{"id":"ObservableArray","name":"ObservableArray","isClass":true,"file":"./packages/async/typings/Async/ObservableArray.d.ts","line":2,"code":"class ObservableArray<T>\ninterface ObservableArray<T> extends Array<T>","doc":"<p>[1]. Encapsulates <code>Array</code> with observable properties; the result works exactly like a regular array, but setting elements outside the bounds of the array (&gt;= length) does NOT work: length must be set first.</p>\n<p>[2]. Type definition to declare Array methods mixin.</p>\n","typeParams":["T"],"items":[{"id":"ObservableArray.fromArray","name":"fromArray","hasParams":true,"isStatic":true,"isMethod":true,"file":"./packages/async/typings/Async/ObservableArray.d.ts","line":4,"code":"static fromArray<T>(array: Array<T>): ObservableArray<T>;","doc":"<p>Create an <code>ObservableArray</code> out of a regular Array.</p>\n","typeParams":["T"],"declType":"ObservableArray<T>"},{"id":"ObservableArray.fromObservableValue","name":"fromObservableValue","hasParams":true,"isStatic":true,"isMethod":true,"file":"./packages/async/typings/Async/ObservableArray.d.ts","line":6,"code":"static fromObservableValue<T>(observableValue: ObservableValue<T[] | T | undefined>): ObservableArray<T>;","doc":"<p>Create an <code>ObservableArray</code> that takes array elements from the array in given <code>ObservableValue</code>, or the value itself as a single element if it is not an array, or an empty array if the value is null or undefined; changes in array elements and/or observable value are reflected asynchronously.</p>\n","typeParams":["T"],"declType":"ObservableArray<T>"},{"id":"ObservableArray.constructor","name":"new ObservableArray","hasParams":false,"isCtor":true,"file":"./packages/async/typings/Async/ObservableArray.d.ts","line":8,"code":"constructor();","doc":"<p>Create a new empty <code>ObservableArray</code> instance.</p>\n"},{"id":"ObservableArray/flattenAsync","name":"flattenAsync","hasParams":true,"isMethod":true,"file":"./packages/async/typings/Async/ObservableArray.d.ts","line":14,"code":"flattenAsync(removeGaps?: boolean): ObservableArray<T>;","doc":"<p>Create a read-only observable array that contains all values from the original array and all nested (observable) arrays, optionally removing gaps (i.e. undefined or null elements); the resulting array and its length <em>always</em> change asynchronously with the contents of the original array, even if not subscribed to a value or the length property.</p>\n","declType":"ObservableArray<T>"},{"id":"ObservableArray/mapAsync","name":"mapAsync","hasParams":true,"isMethod":true,"file":"./packages/async/typings/Async/ObservableArray.d.ts","line":10,"code":"mapAsync<U>(callback: (value: T, index: number, array: T[]) => (ObservableValue<U> | U), thisArg?: any): ObservableArray<U>;","doc":"<p>Create a read-only <code>ObservableArray</code> with each value of the original array mapped to the result of the given getter function; observable values used in the map function are not observed (like <code>ObservableValue#map</code>); the getter is called for combinations of value and index (i.e. deleting a value in the middle of the source array will trigger changes for all elements after it; if the index is not important then use <code>.mapAsyncValues</code> instead); the resulting array length changes along with the original array length.</p>\n","typeParams":["U"],"declType":"ObservableArray<U>"},{"id":"ObservableArray/mapAsyncValues","name":"mapAsyncValues","hasParams":true,"isMethod":true,"file":"./packages/async/typings/Async/ObservableArray.d.ts","line":12,"code":"mapAsyncValues<U>(callbackfn: (value: T) => (ObservableValue<U> | U)): ObservableArray<U>;","doc":"<p>Create a read-only ObservableArray with each value of the original array mapped to the result of the given function; observable values used in the map function are not observed (like ObservableValue map method); the resulting array length changes along with the original array length; this method is slightly more expensive than mapAsync for larger arrays, especially in non-ES6 environments, but is overall more efficient because it avoids unnecessary callbacks when subscribed to.</p>\n","typeParams":["U"],"declType":"ObservableArray<U>"},{"id":"ObservableArray/toJSON","name":"toJSON","hasParams":false,"isMethod":true,"file":"./packages/async/typings/Async/ObservableArray.d.ts","line":16,"code":"toJSON(): T[];","doc":"<p>Represent observable arrays as regular JSON arrays.</p>\n","declType":"T[]"}],"count":2,"sourceIdx":7},{"id":"ObservableObject","name":"ObservableObject","isClass":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":3,"code":"class ObservableObject","doc":"<p>Represents an object with (some) observable members; may be extended into a derived class, or use <code>makeObjectObservable</code> function to mix into any object [requires ES5+ target].</p>\n","items":[{"id":"ObservableObject.PropertyChangeSignal","name":"PropertyChangeSignal","isClass":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":13,"code":"class PropertyChangeSignal extends Signal<string>","doc":"<p>Base class for signals that are emitted when any observed property is modified on an ObservableObject instance, with the name of the property as a parameter.</p>\n","isStatic":true,"extends":["Signal"],"items":[{"id":"ObservableObject.PropertyChangeSignal.target","name":"target","isStatic":true,"isProperty":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":15,"code":"static target: ObservableObject;","doc":"<p>The ObservableObject instance that this signal is used on.</p>\n","declType":"ObservableObject"}],"inherits":["Signal.constructor","Signal/catch","Signal/data","Signal/emit","Signal/results","Signal/then"]},{"id":"ObservableObject.constructor","name":"new ObservableObject","hasParams":false,"isCtor":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":5,"code":"constructor();","doc":"<p>Create an object with (some) observable members.</p>\n"},{"id":"ObservableObject/hasObservableProperty","name":"hasObservableProperty","hasParams":true,"isMethod":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":7,"code":"hasObservableProperty(name: string | number): boolean;","doc":"<p>Returns true if property with given name is observable.</p>\n","declType":"boolean"},{"id":"ObservableObject/PropertyChange","name":"PropertyChange","isProperty":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":9,"code":"PropertyChange: Signal.Emittable<string, typeof ObservableObject.PropertyChangeSignal>;","doc":"<p>Signal that is emitted when any property changes (but does not subscribe to any properties, i.e. only changes to properties already subscribed to, and properties with plain values [not getters] will trigger this signal).</p>\n","declType":"Signal.Emittable<string, typeof ObservableObject.PropertyChangeSignal>","isSignal":true}],"isNamespace":true,"sourceIdx":9},{"id":"ObservableValue","name":"ObservableValue","isClass":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":5,"code":"class ObservableValue<T>","doc":"<p>Represents an observable value (with the value itself in <code>.value</code>).</p>\n","typeParams":["T"],"items":[{"id":"ObservableValue.fromPromise","name":"fromPromise","hasParams":true,"isStatic":true,"isMethod":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":11,"code":"static fromPromise<T>(valuePromise: PromiseLike<T>): ObservableValue<T>;","doc":"<p>Encapsulate given promised value as an ObservableValue; the observed value will start out as <code>undefined</code> but then changes to the <code>Promise</code> result when resolved; or if promise was rejected, hangs on to the error and throws it when retrieving the observable value.</p>\n","typeParams":["T"],"declType":"ObservableValue<T>"},{"id":"ObservableValue.fromSignal","name":"fromSignal","hasParams":true,"isStatic":true,"isMethod":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":13,"code":"static fromSignal<T>(signal: Signal.Emittable<T, typeof Signal>): ObservableValue<T>;","doc":"<p>Connect to given <code>Signal</code>, and create a read-only observable value that always contains the last emitted signal value (initially undefined; the value is only set after the next time the signal is emitted).</p>\n","typeParams":["T"],"declType":"ObservableValue<T>"},{"id":"ObservableValue.fromValue","name":"fromValue","hasParams":true,"isStatic":true,"isMethod":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":9,"code":"static fromValue<T>(value: T): ObservableValue<T>;","doc":"<p>Encapsulate given value as an ObservableValue.</p>\n","typeParams":["T"],"declType":"ObservableValue<T>"},{"id":"ObservableValue.isObserving","name":"isObserving","hasParams":false,"isStatic":true,"isMethod":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":7,"code":"static isObserving(): boolean;","doc":"<p>Returns true if currently running in a subscribed-to observable context (i.e. evaluating an observable value, recording dependencies on other observable values being accessed from this context).</p>\n","declType":"boolean"},{"id":"ObservableValue.constructor","name":"new ObservableValue","hasParams":true,"isCtor":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":15,"code":"constructor(getter?: () => T, setter?: (value: T) => void);","doc":"<p>Create a new (single) observed value using optional getter and setter functions; note that getters <em>should</em> be pure functions without side effects, creating or setting other observables from the getter will result in an error; getter is not called immediately but only when being subscribed to or when obtaining the value itself (from <code>.value</code>).</p>\n"},{"id":"ObservableValue/clear","name":"clear","hasParams":false,"isMethod":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":43,"code":"clear(): void;","doc":"<p>Clear value and remove getter/setter functions, unsubscribe from dependencies.</p>\n","declType":"void"},{"id":"ObservableValue/getLastValue","name":"getLastValue","hasParams":false,"isMethod":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":27,"code":"getLastValue(): T | undefined;","doc":"<p>Returns last value set, does not re-evaluate and/or add dependency.</p>\n","declType":"T | undefined"},{"id":"ObservableValue/getter","name":"getter","hasParams":true,"isMethod":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":17,"code":"getter(f: () => T): this;","doc":"<p>Set a getter function for the observable value, which should return a current value, or another ObservableValue instance, or set <code>.value</code> directly; note that getters <em>should</em> be pure functions without side effects, creating or setting other observables from the getter will result in an error; the getter is only invoked (asynchronously) if a value had been set previously and needs to be updated; reading <code>.value</code> from the getter results in the value previously set, no recursion occurs; returns this.</p>\n","declType":"this"},{"id":"ObservableValue/map","name":"map","hasParams":true,"isMethod":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":29,"code":"map<U>(callback: (value: T) => U): ObservableValue<U>;","doc":"<p>Transform this observable value using given function, into a new ObservableValue instance; note that the transformation function is not necessarily invoked after each value change, if the new observable is not subscribed to and/or multiple changes occur (asynchronously) before the transformation is evaluated; observables used by the given function itself are not automatically subscribed to (wrap given function in observe(…) to observe dependencies as well).</p>\n","typeParams":["U"],"declType":"ObservableValue<U>"},{"id":"ObservableValue/next","name":"next","hasParams":false,"isMethod":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":35,"code":"next(): Promise<T>;","doc":"<p>Start listening for changes to this observable value and all of its dependencies asynchronously, and return a promise for the next (different) value of the observable; does <em>not</em> force evaluation of the current value (i.e. getters are not called); stops subscribing immediately after the promise is resolved.</p>\n","declType":"Promise<T>","isAsync":true},{"id":"ObservableValue/setter","name":"setter","hasParams":true,"isMethod":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":19,"code":"setter(f: (value: T) => void): this;","doc":"<p>Set a setter function for the observable value; setting <code>.value</code> directly from the setter results in changing the underlying observable value (which can also be read by the getter, or the setter itself), no recursion occurs; returns this.</p>\n","declType":"this"},{"id":"ObservableValue/shallow","name":"shallow","isProperty":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":41,"code":"shallow?: boolean;","doc":"<p>Set to true to stop this observablue value instance from converting arrays and objects to observables, and reading values from observable value instances.</p>\n","declType":"boolean"},{"id":"ObservableValue/subscribe","name":"subscribe","hasParams":false,"isMethod":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":31,"code":"subscribe(): this;\nsubscribe(callback: (value: T) => any): this;","doc":"<p>[1]. Start listening for changes to this observable value and all of its dependencies asynchronously; returns this.</p>\n<p>[2]. Start listening for changes to this observable value and all of its dependencies asynchronously, and schedule given function for every new value (including the current value, or undefined if none has been set); returns this.</p>\n","declType":"this | this","count":2},{"id":"ObservableValue/subscribed","name":"subscribed","isProperty":true,"isReadOnly":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":37,"code":"readonly subscribed: boolean;","doc":"<p>True if this observable value is currently subscribed to, either directly or from dependent observables.</p>\n","declType":"boolean"},{"id":"ObservableValue/toString","name":"toString","hasParams":false,"isMethod":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":25,"code":"toString(): string;","doc":"<p>Returns .value as a string (observable if used within an observable getter).</p>\n","declType":"string"},{"id":"ObservableValue/update","name":"update","hasParams":false,"isMethod":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":45,"code":"update(): void;","doc":"<p>Manually invoke the getter function synchronously, if any; can be used only if not currently evaluating another observable value (otherwise, wrap in a call to <code>unobserved</code>); calling this method is normally not necessary, and should only be used if external factors outside of observables change in such a way that the result of the getter function changes; if so, then subsequent retrieval of <code>.value</code> results in the new value, and dependent observable values are scheduled to update automatically (asynchronously).</p>\n","declType":"void"},{"id":"ObservableValue/value","name":"value","isProperty":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":21,"code":"value: T | undefined;","doc":"<p>Observable value, (re-) evaluated only if necessary; when set to an <code>ObservableValue</code> instance, this property returns that instance’s value, until this property is set to another value (except if the <code>ObservableValue</code> has a setter, which is called first); plain Array values are turned into <code>ObservableArray</code> instances, and plain Object instances into <code>ObservableObject</code> instances — unless <code>.shallow</code> is set to true.</p>\n","declType":"T | undefined"},{"id":"ObservableValue/valueOf","name":"valueOf","hasParams":false,"isMethod":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":23,"code":"valueOf(): T | undefined;","doc":"<p>Returns .value (observable if used within an observable getter).</p>\n","declType":"T | undefined"},{"id":"ObservableValue/writable","name":"writable","isProperty":true,"isReadOnly":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":39,"code":"readonly writable: boolean;","doc":"<p>True if this observable value is writable (not only a getter defined).</p>\n","declType":"boolean"}],"sourceIdx":4},{"id":"Promise","name":"Promise","isClass":true,"file":"./packages/async/typings/Async/Promise.d.ts","line":1,"code":"class Promise<T> implements PromiseLike<T>","doc":"<p>Represents a value to be resolved at any time in the future.</p>\n","typeParams":["T"],"items":[{"id":"Promise.all","name":"all","hasParams":true,"isStatic":true,"isMethod":true,"file":"./packages/async/typings/Async/Promise.d.ts","line":15,"code":"static all<ValueT>(promises: PromiseLike<ValueT>[]): Promise<ValueT[]>;","doc":"<p>Return a promise that is fulfilled when all given promises are fulfilled and is immediately rejected when one of the promises is rejected.</p>\n","typeParams":["ValueT"],"declType":"Promise<ValueT[]>","isAsync":true},{"id":"Promise.defer","name":"defer","hasParams":true,"isStatic":true,"isMethod":true,"file":"./packages/async/typings/Async/Promise.d.ts","line":7,"code":"static defer<T>(f: (...args: any[]) => T, args?: any[]): Promise<T>;","doc":"<p>Defer the execution of a callback but return a promise for its result.</p>\n","typeParams":["T"],"declType":"Promise<T>","isAsync":true},{"id":"Promise.delay","name":"delay","hasParams":true,"isStatic":true,"isMethod":true,"file":"./packages/async/typings/Async/Promise.d.ts","line":3,"code":"static delay<T>(f: (...args: any[]) => T, ms: number, args?: any[]): Promise<T>;","doc":"<p>Delay the execution of a callback but return a promise for its result.</p>\n","typeParams":["T"],"declType":"Promise<T>","isAsync":true},{"id":"Promise.fn","name":"fn","hasParams":true,"isStatic":true,"isMethod":true,"file":"./packages/async/typings/Async/Promise.d.ts","line":9,"code":"static fn<T>(callback: (f: (err: any, result: T) => void) => void): Promise<T>;","doc":"<p>Executes given callback, providing it with a Node.js-style (err, result) =&gt; {…} handler that immediately resolves or rejects the resulting promise when called; (use as e.g. <code>Promise.fn(f =&gt; fs.readFile('/etc/passwd', f)).then(...))</code>.</p>\n","typeParams":["T"],"declType":"Promise<T>","isAsync":true},{"id":"Promise.race","name":"race","hasParams":true,"isStatic":true,"isMethod":true,"file":"./packages/async/typings/Async/Promise.d.ts","line":17,"code":"static race<T>(promises: PromiseLike<T>[]): Promise<T>;","doc":"<p>Return a promise that is resolved or rejected exactly like the first of the given promises that is resolved or rejected.</p>\n","typeParams":["T"],"declType":"Promise<T>","isAsync":true},{"id":"Promise.reject","name":"reject","hasParams":true,"isStatic":true,"isMethod":true,"file":"./packages/async/typings/Async/Promise.d.ts","line":13,"code":"static reject(error: Error): Promise<{}>;","doc":"<p>Return a rejected promise.</p>\n","declType":"Promise<{}>","isAsync":true},{"id":"Promise.resolve","name":"resolve","hasParams":true,"isStatic":true,"isMethod":true,"file":"./packages/async/typings/Async/Promise.d.ts","line":11,"code":"static resolve<T>(value: T): Promise<T>;","doc":"<p>Return a resolved promise.</p>\n","typeParams":["T"],"declType":"Promise<T>","isAsync":true},{"id":"Promise.sleep","name":"sleep","hasParams":true,"isStatic":true,"isMethod":true,"file":"./packages/async/typings/Async/Promise.d.ts","line":5,"code":"static sleep<T>(ms: number, value?: T): Promise<T>;","doc":"<p>Return a promise that will be resolved after a delay.</p>\n","typeParams":["T"],"declType":"Promise<T>","isAsync":true},{"id":"Promise.constructor","name":"new Promise","hasParams":true,"isCtor":true,"file":"./packages/async/typings/Async/Promise.d.ts","line":19,"code":"constructor(executor?: (resolve: (value: PromiseLike<T> | T) => void, reject: (error: Error) => void) => void);","doc":"<p>Create a new Promise instance by running the given callback function, which is given callbacks to resolve and/or reject the promise; the promise is also rejected if the callback function throws an exception.</p>\n"},{"id":"Promise/catch","name":"catch","hasParams":true,"isMethod":true,"file":"./packages/async/typings/Async/Promise.d.ts","line":25,"code":"catch<O>(onRejected?: (error: Error) => (PromiseLike<O> | O)): Promise<O>;\ncatch<O>(onRejected?: (error: Error) => void): Promise<O>;","doc":"<p>Catch rejections and return a new promise.</p>\n","typeParams":["O"],"declType":"Promise<O> | Promise<O>","isAsync":true},{"id":"Promise/then","name":"then","hasParams":true,"isMethod":true,"file":"./packages/async/typings/Async/Promise.d.ts","line":21,"code":"then<O>(onFulfilled?: (value: T) => (PromiseLike<O> | O), onRejected?: (error: Error) => (PromiseLike<O> | O)): Promise<O>;\nthen<O>(onFulfilled?: (value: T) => (PromiseLike<O> | O), onRejected?: (error: Error) => void): Promise<O>;","doc":"<p>Run one of the callbacks as soon as the promise is fulfilled or rejected.</p>\n","typeParams":["O"],"declType":"Promise<O> | Promise<O>","isAsync":true}],"sourceIdx":23},{"id":"Signal","name":"Signal","isClass":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":10,"code":"class Signal<T>","doc":"<p>Encapsulates a signal that can be used to trigger one or more handlers asynchronously; do <em>not</em> construct <code>Signal</code> classes directly, use <code>defineSignal</code> to create derived classes which can be instantiated and emitted.</p>\n","typeParams":["T"],"items":[{"id":"Signal.Emittable","name":"Emittable","isInterface":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":40,"code":"interface Emittable<T, SignalClassT extends typeof Signal>","doc":"<p>Type definition for a callable (emittable) signal <em>class</em>; matches the result of <code>defineSignal</code>; the type parameters represent handler function arguments: signal payload, and emitted signal type.</p>\n","isStatic":true,"typeParams":["T","SignalClassT extends typeof Signal"],"items":[{"id":"Signal.Emittable.constructor","name":"new","hasParams":true,"isCtor":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":42,"code":"new (data: T): Signal<T>;","doc":"<p>Instantiate a signal with given value, ready to be emitted.</p>\n","declType":"Signal<T>"},{"id":"Signal.Emittable.!call","name":"<call>","hasParams":true,"isMethod":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":44,"code":"(data?: T): void;","doc":"<p>Emit a signal with given value; does not instantiate this class unless there are actually handlers connected to it.</p>\n","declType":"void"},{"id":"Signal.Emittable/connect","name":"connect","hasParams":true,"isMethod":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":46,"code":"connect(handler: (data: T, source: SignalClassT) => any): SignalConnection;\nconnect(method: string, target: {}): SignalConnection;","doc":"<p>[1]. Add a handler to be invoked when this signal is emitted; returns an encapsulation of the connection with a disconnect method.</p>\n<p>[2]. Add a handler to be invoked when this signal is emitted: a method with given name on given target object (resolved only when needed); returns an encapsulation of the connection with a disconnect method.</p>\n","declType":"SignalConnection | SignalConnection","count":2},{"id":"Signal.Emittable/connectOnce","name":"connectOnce","hasParams":true,"isMethod":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":50,"code":"connectOnce(handler: (data: T, source: SignalClassT) => any): void;\nconnectOnce(method: string, target: {}): void;","doc":"<p>[1]. Add a handler to be invoked the next time this signal is emitted.</p>\n<p>[2]. Add a handler to be invoked the next time this signal is emitted: a method with given name on given target object (resolved only when needed).</p>\n","declType":"void | void","count":2},{"id":"Signal.Emittable/disconnectAll","name":"disconnectAll","hasParams":false,"isMethod":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":54,"code":"disconnectAll(): this;","doc":"<p>Remove all handlers.</p>\n","declType":"this"},{"id":"Signal.Emittable/isConnected","name":"isConnected","hasParams":false,"isMethod":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":56,"code":"isConnected(): boolean;","doc":"<p>Returns true if this signal has any handlers connected to it.</p>\n","declType":"boolean"},{"id":"Signal.Emittable/observe","name":"observe","hasParams":false,"isMethod":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":58,"code":"observe(): ObservableValue<T>;","doc":"<p>Create a read-only observable value that contains the last emitted value (initially undefined, only contains a value after the first time this signal is emitted).</p>\n","declType":"ObservableValue<T>"}]},{"id":"Signal.onHandlerConnected","name":"onHandlerConnected","isStatic":true,"isProperty":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":22,"code":"protected static onHandlerConnected?: () => void;","doc":"<p>Static method that is called synchronously when a first handler is connected (and when a new handler is connected after all had been disconnected); override this in a signal base class, e.g. to add a delayed initialization method.</p>\n","isProtected":true,"declType":"() => void"},{"id":"Signal.onHandlersDisconnected","name":"onHandlersDisconnected","isStatic":true,"isProperty":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":24,"code":"protected static onHandlersDisconnected?: () => void;","doc":"<p>Static method that is called synchronously when no more handlers are connected; override this in a signal base class, e.g. to add a delayed deallocation method.</p>\n","isProtected":true,"declType":"() => void"},{"id":"Signal.constructor","name":"new Signal","hasParams":true,"isCtor":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":26,"code":"constructor(data: T);","doc":"<p>Create a signal with given payload data, ready to be emitted.</p>\n"},{"id":"Signal/catch","name":"catch","hasParams":true,"isMethod":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":32,"code":"catch<O>(onRejected?: (error: Error) => O): Promise<O>;","doc":"<p>Catch errors that occur during execution of all handlers; returns a Promise that resolves to the return value of the callback itself.</p>\n","typeParams":["O"],"declType":"Promise<O>","isAsync":true},{"id":"Signal/data","name":"data","isProperty":true,"isReadOnly":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":36,"code":"readonly data: T;","doc":"<p>The payload data for this signal instance.</p>\n","declType":"T"},{"id":"Signal/emit","name":"emit","hasParams":true,"isMethod":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":28,"code":"emit(noResults?: boolean): this;","doc":"<p>Invoke all handlers and capture promises of their return values in .results (unless argument is true); works only once; returns this.</p>\n","declType":"this"},{"id":"Signal/results","name":"results","isProperty":true,"isReadOnly":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":34,"code":"readonly results: Promise<any>[];","doc":"<p>Array of Promises that resolve to return values of all handlers.</p>\n","declType":"Promise<any>[]","isAsync":true},{"id":"Signal/then","name":"then","hasParams":true,"isMethod":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":30,"code":"then<O>(onFulfilled?: (results: any[]) => O, onRejected?: (error: Error) => O): Promise<O>;","doc":"<p>Invoke given callback(s) with return values of all handlers, or any exception that occurred during execution of all handlers; returns a Promise that resolves to the return value of the callback(s) itself.</p>\n","typeParams":["O"],"declType":"Promise<O>","isAsync":true}],"isNamespace":true,"sourceIdx":26},{"id":"SignalConnection","name":"SignalConnection","isInterface":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":3,"code":"interface SignalConnection","doc":"<p>Encapsulates a handler connected to a signal.</p>\n","items":[{"id":"SignalConnection/disconnect","name":"disconnect","hasParams":false,"isMethod":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":5,"code":"disconnect(): void;","doc":"<p>Disconnect the connected handler from this signal.</p>\n","declType":"void"},{"id":"SignalConnection/disconnected","name":"disconnected","isProperty":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":7,"code":"disconnected: boolean;","doc":"<p>True if connection has been disconnected.</p>\n","declType":"boolean"}],"sourceIdx":25},{"id":"defer","name":"defer","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/Defer.d.ts","line":1,"code":"function defer(f: (...args: any[]) => void, args?: any[] | IArguments): void;","doc":"<p>Execute given function only when idle, with given arguments (array or <code>arguments</code> object) if any.</p>\n","declType":"void","sourceIdx":38,"text":[{"title":"Example","content":"<pre><code class=\"language-typescript\">console.log(&quot;1&quot;);\nAsync.defer(() =&gt; { console.log(&quot;2&quot;) });\nconsole.log(&quot;3&quot;);\n// output: 1, 3, 2\n</code></pre>\n"}]},{"id":"defineSignal","name":"defineSignal","hasParams":false,"isFunction":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":62,"code":"function defineSignal<T>(): Signal.Emittable<T, typeof Signal>;\nfunction defineSignal<SignalT extends typeof Signal, T>(Base: SignalT & { new (...args): { data: T; }; }, properties?: {}): SignalT & Signal.Emittable<T, SignalT>;","doc":"<p>[1]. Create a new emittable signal class that derives directly from <code>Signal</code>, with given payload type.</p>\n<p>[2]. Create a new emittable signal class that derives from given base class (which must derive from <code>Signal</code>), and copy given static properties onto the resulting class.</p>\n","typeParams":["T"],"declType":"Signal.Emittable<T, typeof Signal> | SignalT & Signal.Emittable<T, SignalT>","count":2,"sourceIdx":27,"text":[{"title":"Example","content":"<pre><code class=\"language-typescript\">// define a signal with a payload of type `string`\nvar MySignal = Async.defineSignal&lt;string&gt;();\n\n// connect a handler\nMySignal.connect(text =&gt; {\n    console.log(&quot;Received: &quot; + text);\n});\n\n// invoke all connected handlers:\nMySignal(&quot;foo&quot;);\n</code></pre>\n"}]},{"id":"deleteObservableProperty","name":"deleteObservableProperty","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":23,"code":"function deleteObservableProperty(obj: {}, member: string | number): void;","doc":"<p>Delete the property with given name and clear its observable value.</p>\n","declType":"void","sourceIdx":12},{"id":"inject","name":"inject","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/Inject.d.ts","line":3,"code":"function inject<SpecT extends { [name: string]: any; }>(targetClass: Function, spec: SpecT): SpecT;","doc":"<p>Set given injectable observable properties (decorated with <code>injectable</code>) on <em>all</em> instances of given class and derived classes to the given values, except for instances where the property has been overwritten directly; may be called multiple times even with the same properties to redefine their injected value; returns an object that contains the previous injected values (for e.g. overriding an injected function that calls into the previously injected function; when injecting into a derived class, these properties use accessors to return latest overridden injected values on base class(es) dynamically).</p>\n","typeParams":["SpecT extends {\r\n    [name: string]: any;\r\n}"],"declType":"SpecT","sourceIdx":3,"textSeeAlso":"injectable, samples/injection","text":[]},{"id":"isObservableProperty","name":"isObservableProperty","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":25,"code":"function isObservableProperty(obj: {}, member: string | number): boolean;","doc":"<p>Returns true if property with given name is defined and is observable.</p>\n","declType":"boolean","sourceIdx":13},{"id":"makeObjectObservable","name":"makeObjectObservable","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":19,"code":"function makeObjectObservable<T extends {}>(obj: T): T & ObservableObject;","doc":"<p>Returns a new <code>ObservableObject</code> with properties copied from given object; <code>ObservableValue</code> instances are referenced directly (including getter and setter), Array properties are turned into <code>ObservableArray</code> instances, and plain Object instances into <code>ObservableObject</code> instances; also seals the new instance if the object parameter was sealed, and freezes it if the object parameter was frozen.</p>\n","typeParams":["T extends {}"],"declType":"T & ObservableObject","sourceIdx":10},{"id":"makePropertyObservable","name":"makePropertyObservable","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":21,"code":"function makePropertyObservable(obj: {}, member: string | number, instance?: ObservableValue<any>): void;","doc":"<p>Make the property with given name observable; use given observable value instance, if any, otherwise use a new observable value instance that holds the current property value and/or uses the current property getter and setter [requires ES5+ target].</p>\n","declType":"void","sourceIdx":11,"textSeeAlso":"observable","text":[{"title":"","content":"<p>To define observable properties on a class, use the <code>@observable</code> decorator.</p>\n"}]},{"id":"observe","name":"observe","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":48,"code":"function observe<T>(f: () => T): ObservableValue<T>;\nfunction observe<T>(promise: PromiseLike<T>): ObservableValue<T>;\nfunction observe<T>(obj: Array<T>): ObservableArray<T>;\nfunction observe<T extends {}>(obj: T): T & ObservableObject;","doc":"<p>[1]. Create a (single) observable that holds the return value of the given function, re-evaluated (when subscribed to) whenever one of the observable values used in the getter function change, <em>or</em> (also when not subscribed to) when <code>ObservableValue#value</code> is read after one of the observables used in the getter function (may have) changed its value; note that getters <em>should</em> be pure functions without side effects, creating or setting other observables from the getter will result in an error.</p>\n<p>[2]. Encapsulate given promise as an observable value that is set when the promise resolves; if the promise is already resolved, the observable value is set to the promise’s value immediately; if or when the promise is rejected, the error is stored and will be thrown when trying to obtain the observable value.</p>\n<p>[3]. Returns a new ObservableArray with elements copied from given array; (same as <code>ObservableArray.fromArray</code>; does not observe values of a given <code>ObservableArray</code>, see <code>observeArray</code> instead).</p>\n<p>[4]. Returns a new ObservableObject with properties copied from given object; (same as new ObservableObject(…) but with a strongly typed return value).</p>\n","typeParams":["T"],"declType":"ObservableValue<T> | ObservableValue<T> | ObservableArray<T> | T & ObservableObject","count":4,"sourceIdx":5,"textSeeAlso":"unobserved, observable, unobservable","text":[]},{"id":"observeArray","name":"observeArray","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/ObservableArray.d.ts","line":22,"code":"function observeArray<T>(f: () => (T[] | T | undefined)): ObservableArray<T>;","doc":"<p>Returns an ObservableArray instance based on the result of given function: if the returned value is an array, then all elements are copied to the result; if the returned value is an observable array, all elements are proxied; if the returned value is not an array, the result contains this value as a single element; if the returned value is null or undefined, the result will be an empty array; changes in values/elements are reflected asynchronously.</p>\n","typeParams":["T"],"declType":"ObservableArray<T>","sourceIdx":8,"text":[{"title":"Example","content":"<pre><code class=\"language-typescript\">// define a class with a property that *may* be a list of strings\nclass Foo {\n    @Async.observable\n    public bar?: string[];\n}\nvar myFoo = new Foo();\n\n// this becomes an empty array if the `bar` property was undefined:\nvar myObservableArray = Async.observeArray(() =&gt; myFoo.bar);\n\n// so this is always a valid list of uppercase strings:\nvar myMap = myObservableArray.mapObservable(v =&gt; v.toUpperCase());\n</code></pre>\n"}]},{"id":"sleep","name":"sleep","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/Promise.d.ts","line":30,"code":"function sleep<PromiseT>(ms: number, value?: PromiseT): Promise<PromiseT | undefined>;","doc":"<p>Return a promise that will be resolved after a delay.</p>\n","typeParams":["PromiseT"],"declType":"Promise<PromiseT | undefined>","isAsync":true,"sourceIdx":24,"text":[{"title":"","content":"<p>This is an alias of the <code>Promise.sleep</code> method.</p>\n"}]},{"id":"unobserved","name":"unobserved","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/Observable.d.ts","line":56,"code":"function unobserved<T>(f: ((...args: any[]) => T), ...args: any[]): T;","doc":"<p>Invoke given function without recording dependencies on currently evaluating observable values; passes on the <code>this</code> value given to this function, returns the function’s return value.</p>\n","typeParams":["T"],"declType":"T","sourceIdx":6,"text":[{"title":"Usage","content":"<p>This function is particularly useful if an observable value getter executes methods or constructors that are not in the scope of the current module, and may or may not create/evaluate further observable values. Since an observable value getter cannot have any side effects, you will need to wrap the code in a call to <code>unobserved</code>.</p>\n<p>E.g. if you are caching an instance of another module’s class on first access of an observable value, you need to use <code>unobserved</code>. See the example below:</p>\n<pre><code class=\"language-typescript\">// this is defined elsewhere: ...\nclass Label {\n    constructor(text: string) { /* ... side effects? ... */ }\n    setText(text: string) { /* ... */ }\n}\n\n// cache a Label instance for an observable value\nvar text = Async.ObservableValue.fromValue(&quot;Hello, world!&quot;);\nvar _label: Label;\nvar label = Async.observe(() =&gt; {\n    var t = text;\n    if (!t) {\n        // forget the cached Label instance, if any\n        _label = undefined;\n    }\n    else if (!_label) {\n        // create a Label, unobserved\n        _label = Async.unobserved(() =&gt; new Label(t));\n    }\n    else {\n        // use the existing instance\n        Async.unobserved(() =&gt; _label.setText(t));\n    }\n    return _label;\n});\n</code></pre>\n<p>However, usually such constructs are better expressed using the <a href=\"#ObservableValue_map\"><code>.map</code></a> method, since the callback given to this method is always run within <code>unobserved</code> while still depending on the input observable:</p>\n<pre><code class=\"language-typescript\">var _label: Label;\nvar label = Async.observe(() =&gt; text)  // or just &quot;text&quot;.\n    .map(t =&gt; {\n        if (!t) _label = undefined;\n        else if (!_label) _label = new Label(t);\n        else _label.setText(t);\n        return _label;\n    });\n</code></pre>\n"}]},{"id":"yieldAll","name":"yieldAll","hasParams":false,"isFunction":true,"file":"./packages/async/typings/Async/Defer.d.ts","line":3,"code":"function yieldAll(): boolean;","doc":"<p>Run a batch of deferred functions; returns true if there are still more deferred functions in the queue (or false to stop infinite recursion if already running).</p>\n","declType":"boolean","sourceIdx":1,"text":[{"title":"","content":"<p>This function can be used to make all asynchronous activity run synchronously, if the current context was invoked externally (e.g. from a DOM event).</p>\n"},{"title":"Example","content":"<pre><code class=\"language-typescript\">var MySignal = Async.defineSignal&lt;MouseEvent&gt;();\nvar button = document.createElement(&quot;button&quot;);\nbutton.onclick = event =&gt; {\n    MySignal(event);\n    while (Async.yieldAll());\n};\n\n// now we can connect to the signal and prevent the click,\n// before returning from the event handler\nMySignal.connect(event =&gt; {\n    event.preventDefault();\n});\n</code></pre>\n"}]},{"id":"injectable","name":"injectable","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/Inject.d.ts","line":1,"code":"function injectable(target: Object, key: string, descriptor?: PropertyDescriptor): any;","doc":"<p><em>Property decorator</em>, makes a property observable on every instance, with a read-only value shared across all instances taken from an (earlier OR later) call to <code>inject</code>, <em>until</em> the property is directly assigned to [requires ES5+ target] [decorator].</p>\n","isDecorator":true,"sourceIdx":2,"textSeeAlso":"inject, samples/injection","text":[]},{"id":"observable","name":"observable","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":31,"code":"function observable(target: Object, key: string, descriptor?: PropertyDescriptor): any;","doc":"<p><em>Property/accessor decorator</em>, makes a property observable on every instance [requires ES5+ target] [decorator].</p>\n","isDecorator":true,"sourceIdx":16,"textSeeAlso":"unobservable","text":[{"title":"","content":"<p><strong>Note:</strong> properties that are decorated with <code>@observable</code> will <em>not</em> be enumerable on the instance object, because getters and setters are defined on the prototype object. If you need properties to be enumerable, call <code>makePropertyObservable(...)</code> from the constructor instead.</p>\n<p><strong>Note:</strong> values assigned to properties decorated with <code>@observable</code> will be treated specially, if they are arrays or objects created with an object literal:</p>\n<ol>\n<li>Arrays are replaced with instances of <code>ObservableArray</code>; by nature of this class, the array elements are <em>also</em> treated recursively;</li>\n<li>Objects that derive directly from <code>Object</code> are replaced with instances of <code>ObservableObject</code> through <code>makeObjectObservable(...)</code>. By nature of this function, all enumerable properties of the original object will <em>also</em> be treated recursively.</li>\n</ol>\n<p>This recursive behavior makes it easy to implement observable state objects where all properties of the state are observable, but it may lead to performance issues with large data structures. If you only need to observe the object reference itself, use <code>observable_shallow</code>.</p>\n"}]},{"id":"observable_freeze","name":"observable_freeze","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":43,"code":"function observable_freeze(target: Object, key: string, descriptor?: PropertyDescriptor): any;","doc":"<p><em>Property/accessor decorator</em>, makes a property observable on every instance and enforces that values are not undefined or null when read (throws TypeError) and that only instances of Object can be set, which are frozen automatically [requires ES5+ target] [decorator].</p>\n","isDecorator":true,"sourceIdx":22,"textSeeAlso":"observable","text":[]},{"id":"observable_not_null","name":"observable_not_null","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":39,"code":"function observable_not_null(target: Object, key: string, descriptor?: PropertyDescriptor): any;","doc":"<p><em>Property/accessor decorator</em>, makes a property observable on every instance and enforces that values are not undefined or null when read (throws TypeError) and that undefined/null values cannot be set (also throws TypeError) [requires ES5+ target] [decorator].</p>\n","isDecorator":true,"sourceIdx":20,"textSeeAlso":"observable","text":[]},{"id":"observable_number","name":"observable_number","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":35,"code":"function observable_number(target: Object, key: string, descriptor?: PropertyDescriptor): any;","doc":"<p><em>Property/accessor decorator</em>, makes a property observable on every instance and converts values to numbers using Number(…) when read [requires ES5+ target] [decorator].</p>\n","isDecorator":true,"sourceIdx":18,"textSeeAlso":"observable","text":[]},{"id":"observable_seal","name":"observable_seal","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":41,"code":"function observable_seal(target: Object, key: string, descriptor?: PropertyDescriptor): any;","doc":"<p><em>Property/accessor decorator</em>, makes a property observable on every instance and enforces that values are not undefined or null when read (throws TypeError) and that only instances of Object can be set, which are sealed automatically [requires ES5+ target] [decorator].</p>\n","isDecorator":true,"sourceIdx":21,"textSeeAlso":"observable","text":[]},{"id":"observable_shallow","name":"observable_shallow","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":37,"code":"function observable_shallow(target: Object, key: string, descriptor?: PropertyDescriptor): any;","doc":"<p><em>Property/accessor decorator</em>, makes a property observable on every instance, as a shallow observable value (i.e. does not read values from observable values assigned to this property; and does not convert arrays to observable arrays nor objects to observable objects) [requires ES5+ target] [decorator].</p>\n","isDecorator":true,"sourceIdx":19,"textSeeAlso":"observable, ObservableValue/shallow","text":[{"title":"","content":"<p>Use this decorator for properties that may contain larger data structures, where you only want to observe the property itself and not any of the structure’s properties.</p>\n"}]},{"id":"observable_string","name":"observable_string","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":33,"code":"function observable_string(target: Object, key: string, descriptor?: PropertyDescriptor): any;","doc":"<p><em>Property/accessor decorator</em>, makes a property observable on every instance and converts values to strings when read (empty string for null/undefined/NaN) [requires ES5+ target] [decorator].</p>\n","isDecorator":true,"sourceIdx":17,"textSeeAlso":"observable","text":[]},{"id":"unobservable","name":"unobservable","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":27,"code":"function unobservable(target: Object, key: string, descriptor?: PropertyDescriptor): any;","doc":"<p><em>Method/accessor decorator</em>, wraps a method or getter (but not setter) in an <code>unobserved</code> call, so that any observable values read by this method (or functions invoked synchronously from within this method) are not marked as dependencies of any currently evaluating observable values [requires ES5+ target] [decorator].</p>\n","isDecorator":true,"sourceIdx":14,"textSeeAlso":"observable","text":[{"title":"","content":"<p><strong>Note:</strong> properties that are decorated with <code>@unobservable</code> will <em>not</em> be enumerable on the instance object, because the getter wrapper is defined on the prototype object.</p>\n"}]},{"id":"unobservable_memoize_get","name":"unobservable_memoize_get","hasParams":true,"isFunction":true,"file":"./packages/async/typings/Async/ObservableObject.d.ts","line":29,"code":"function unobservable_memoize_get(target: Object, key: string, descriptor?: PropertyDescriptor): any;","doc":"<p><em>Read-only-accessor decorator</em>, wraps a getter (without setter) in an <code>unobserved</code> call, so that any observable values read by the accessor (or functions invoked synchronously from within the accessor) are not marked as dependencies of any currently evaluating observable values; defines a read-only property using the result of the accessor call, after the first time it was invoked for each instance [requires ES5+ target] [decorator].</p>\n","isDecorator":true,"sourceIdx":15,"textSeeAlso":"observable, unobservable","text":[{"title":"","content":"<p><strong>Note:</strong> properties that are decorated with <code>@unobservable_memoize_get</code> will <em>not</em> be enumerable on the instance object <strong>until they are evaluated once</strong>, because the getter wrapper is defined on the prototype object.</p>\n<p>Only when the getter has run once for a given instance, that instance will receive a read-only property that masks the prototype getter.</p>\n"}]},{"id":"UnhandledException","name":"UnhandledException","isVar":true,"file":"./packages/async/typings/Async/Signal.d.ts","line":70,"code":"UnhandledException: Signal.Emittable<Error, typeof Signal>","doc":"<p>Signal that is triggered with exceptions that were unhandled during async execution; a custom handler may be added here, the default handler just writes a warning message to the console; to disable this behavior for specific errors, set error.message to a blank string.</p>\n","declType":"Signal.Emittable<Error, typeof Signal>","isSignal":true,"sourceIdx":28},{"id":"~reference","name":"Reference","textSlug":"reference","text":[],"toc":["ObservableArray","ObservableObject","ObservableValue","Promise","Signal","SignalConnection","defer","defineSignal","deleteObservableProperty","inject","isObservableProperty","makeObjectObservable","makePropertyObservable","observe","observeArray","sleep","unobserved","yieldAll","injectable","observable","observable_freeze","observable_not_null","observable_number","observable_seal","observable_shallow","observable_string","unobservable","unobservable_memoize_get","UnhandledException"]}]}